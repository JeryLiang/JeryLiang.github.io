{"title":"消息队列(一)——消息队列的应用场景","uid":"96ba06db63c23312ef17859b33c16987","slug":"消息队列-一-——消息队列的应用场景","date":"2019-12-06T08:32:24.000Z","updated":"2021-08-16T12:40:35.607Z","comments":true,"path":"api/articles/消息队列-一-——消息队列的应用场景.json","keywords":null,"cover":"../img/MQ/cover1.png","content":"<h4 id=\"1-什么是消息队列\"><a href=\"#1-什么是消息队列\" class=\"headerlink\" title=\"1. 什么是消息队列\"></a>1. 什么是消息队列</h4><hr>\n<p>队列相信大家应该都不陌生，它是一种先进先出的数据结构，基本结构如下图。</p>\n<p><img src=\"../img/MQ/1-1.png\" alt=\"队列\"></p>\n<p>在java中已经实现了各种各样的队列了，那为什么还需要消息队列MQ（Message Queue）这种中间件呢？我们可以先尝试思考一下消息队列存在的意义，它能满足我们项目中的什么需求，下面我会继续补充。</p>\n<p>消息队列可以简单理解为，我们把想要传输的数据放到队列中（其结构与普通队列是一样的）</p>\n<p><img src=\"../img/MQ/1-2.png\" alt=\"消息队列\"></p>\n<p>我们将把数据放入到队列的那一方叫做<code>生产者</code>；将从消息队列中取数据的一方叫做<code>消费者</code>。</p>\n<h4 id=\"2-为什么要使用消息队列\"><a href=\"#2-为什么要使用消息队列\" class=\"headerlink\" title=\"2. 为什么要使用消息队列\"></a>2. 为什么要使用消息队列</h4><hr>\n<p>以下我将通过几个简单的场景来简单说明我们为什么使用消息队列。</p>\n<h5 id=\"2-1-解耦\"><a href=\"#2-1-解耦\" class=\"headerlink\" title=\"2.1 解耦\"></a>2.1 解耦</h5><hr>\n<p>假设我们现在有一个环境数据生成系统A，系统A通过调用系统B和系统C的接口来向系统B、C来发送数据，场景一图如下：<br><img src=\"../img/MQ/1-3.png\" alt=\"场景1\"></p>\n<p>即系统A在有新的环境数据生成时，会通过调用B、C系统的接口来将生成的数据发送给B、C。写成伪代码如下所示（此处不考虑用观察者模式实现解耦并实时通知观察者的情况）：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public class SystemA &#123;\n &#x2F;&#x2F; 系统B和系统C的依赖\n SystemB systemB &#x3D; new SystemB();\n SystemC systemC &#x3D; new SystemC();\n &#x2F;&#x2F; 系统A独有的数据\n private String environmentData&#x3D; &quot;data&quot;;\n public void doSomething() &#123;\n &#x2F;&#x2F; 通过调用接口发送数据\n systemB.SystemBNeed2do(environmentData);\n systemC.SystemCNeed2do(environmentData);\n &#125;\n&#125;</code></pre>\n<p>这种情况下，会有以下问题：</p>\n<ul>\n<li>如果某一天系统B不需要这些数据了，让系统A的负责人将发送数据给他们的那一部分代码给改了，即注释掉<code>systemB.SystemBNeed2do(environmentData);</code>；</li>\n<li>有新的系统D需要这些数据了，需要增加调用D系统接口来发送数据的代码；</li>\n<li>同时，系统A还需要考虑如果其余系统B、C、D的系统如果挂了怎么办，要不要重发。</li>\n</ul>\n<p>从上面的场景可以发现，系统A与其他三个系统高度耦合了。我们试想如下场景二，系统A将最新的环境数据信息放到MQ中，哪个系统需要就可以订阅这个消息消费。如果某个系统不需要这些数据了，就取消对MQ消息的消费即可。这种场景下，A系统完全不需要去考虑将数据发送给谁，也不需要去维护之前发送数据的代码，不需要考虑其他系统是否调用成功、失败超时等情况。</p>\n<p><img src=\"../img/MQ/1-4.png\" alt=\"场景2\"></p>\n<p><strong>小结</strong>：<br>通过这种模式消息发布与订阅的模式，使得系统A与其他系统解耦。</p>\n<h5 id=\"2-2-异步\"><a href=\"#2-2-异步\" class=\"headerlink\" title=\"2.2 异步\"></a>2.2 异步</h5><hr>\n<p>其实我仔细斟酌了一下异步与解耦的场景，发现其实异步与解耦是有一定关系的，我们使用同样的场景，只是我们考虑的面不同，场景三如下图所示。但我们现在考虑的面是时间效率。<br><img src=\"../img/MQ/1-5.png\" alt=\"场景3\"></p>\n<p>假设系统A产生环境数据需要100ms，调用系统B、C、D的接口分别需要300ms、300ms、300ms，那么在类似场景一的设计方式时，这次请求所需要耗费的时间为100+300+300+300 = 1000ms = 1s。请求会随着需要环境数据的系统越来越多而使得请求响应越来越慢，这是用户不能忍受的，即类似我们去请求一个系统服务，我们主要想要的服务只是系统A生成的环境数据服务，而系统A这个时候却因为其它系统调用而使得这个服务请求响应过慢。</p>\n<p>而如果是类似于如下场景时，我们的响应时间仅仅是产生消息的时间100ms。<br><img src=\"../img/MQ/1-6.png\" alt=\"场景4\"></p>\n<p><strong>小结</strong>：</p>\n<ul>\n<li>同步场景下，整个请求需要耗时1s；</li>\n<li>异步场景下，请求只需要100ms。</li>\n</ul>\n<h5 id=\"2-3-削峰-限流\"><a href=\"#2-3-削峰-限流\" class=\"headerlink\" title=\"2.3 削峰/限流\"></a>2.3 削峰/限流</h5><hr>\n<p>我们接着考虑如下场景，假设我们的系统A有个促销功能，大促销期间并发量较大，我们假设每秒可能有5k个请求。如下图。<br><img src=\"../img/MQ/1-7.png\" alt=\"场景5\"></p>\n<p>一般的MySQL，每秒能处理2k个请求就差不多了，如果每秒5k个请求同时处理的话，可能会导致MySQL不可用，导致整个系统崩溃，用户也就没法使用MySQL了。但一过了促销期，每秒请求只有百来个，这个时候对系统几乎没有任何压力。</p>\n<p>如果使用MQ，每秒5k个请求写入MQ，A系统可以根据自身的处理能力来决定每秒拉取的请求数。这样下来，在高峰期时系统A也不会挂掉。<br><img src=\"../img/MQ/1-8.png\" alt=\"场景6\"></p>\n<p>这个短暂的高峰期积压是完全OK的。（消息队列是支持吞高吐量的，为此不用担心这个量的问题，同样，我们可以暂不考虑MQ挂掉的情况）。<br>系统A按照它能处理的速率来处理请求。</p>\n<p><strong>小结</strong>：<br>通过将请求放在支持高吞吐量的MQ中来到达削峰/限流的效果。</p>\n<h5 id=\"2-4-其它应用场景\"><a href=\"#2-4-其它应用场景\" class=\"headerlink\" title=\"2.4 其它应用场景\"></a>2.4 其它应用场景</h5><hr>\n<ul>\n<li><strong>日志处理</strong>：将大量日志存储到消息队列中（一般采用分布式消息队列kafka），解决大量日志传输的问题。其中，消息队列负责日志数据的接收，存储和转发；</li>\n<li><strong>消息通讯</strong>：点对点通讯或聊天室通讯。</li>\n</ul>\n<h4 id=\"3-使用消息队列会有什么优缺点\"><a href=\"#3-使用消息队列会有什么优缺点\" class=\"headerlink\" title=\"3. 使用消息队列会有什么优缺点\"></a>3. 使用消息队列会有什么优缺点</h4><hr>\n<p>优点其实就是上文中谈到的，在特殊场景下的应用好处，解耦、异步与削峰等。</p>\n<p> <strong>系统可用性</strong>：<br>系统因为依赖与MQ消息队列这个服务，若这个服务崩溃了，那么我们的整个系统将不可用。为此往往我们都是通过集群/分布式部署来实现MQ高可用的。 </p>\n<p><strong>系统复杂度</strong>：<br>我们将数据写到消息队列上，就有可能会存在数据丢失的情况。以及我们如何保证消息没有被重复消费等问题。</p>\n<p><strong>一致性问题</strong>：<br>A系统将请求写入到消息队列后就返回请求成功了，假设在多机部署的时候，系统B、C写库成功，假设D写入失败了，这种情况下就会产生数据不一致的问题。</p>\n<h4 id=\"4-后语\"><a href=\"#4-后语\" class=\"headerlink\" title=\"4. 后语\"></a>4. 后语</h4><hr>\n<p>总的来说，虽然引入消息队列有很多好处，但是也得针对它的缺点来引入其它技术方案和架构来规避这些问题，所以我们应该按照我们的实际需求与场景，来选择我们的技术方案。</p>\n<p>本人水平有限，难免有错误或遗漏之处，望大家指正和谅解，欢迎评论留言。</p>\n","feature":true,"text":"1. 什么是消息队列 队列相信大家应该都不陌生，它是一种先进先出的数据结构，基本结构如下图。 在java中已经实现了各种各样的队列了，那为什么还需要消息队列MQ（Message Queue）这种中间件呢？我们可以先尝试思考一下消息队列存在的意义，它能满足我们项目中的什么需求，下面...","link":"","photos":[],"count_time":{"symbolsCount":"2.4k","symbolsTime":"2 mins."},"categories":[{"name":"MQ","slug":"MQ","count":3,"path":"api/categories/MQ.json"}],"tags":[{"name":"MQ应用场景","slug":"MQ应用场景","count":1,"path":"api/tags/MQ应用场景.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97\"><span class=\"toc-text\">1. 什么是消息队列</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97\"><span class=\"toc-text\">2. 为什么要使用消息队列</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-1-%E8%A7%A3%E8%80%A6\"><span class=\"toc-text\">2.1 解耦</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-2-%E5%BC%82%E6%AD%A5\"><span class=\"toc-text\">2.2 异步</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-3-%E5%89%8A%E5%B3%B0-%E9%99%90%E6%B5%81\"><span class=\"toc-text\">2.3 削峰&#x2F;限流</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-4-%E5%85%B6%E5%AE%83%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">2.4 其它应用场景</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E4%BD%BF%E7%94%A8%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%BC%9A%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%BC%BA%E7%82%B9\"><span class=\"toc-text\">3. 使用消息队列会有什么优缺点</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E5%90%8E%E8%AF%AD\"><span class=\"toc-text\">4. 后语</span></a></li></ol>","author":{"name":"安安哎呀呀","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/img_convert/71d174e6f2050f828d65a741734d6e0c.png","link":"/","description":"山内有樱名为良，树本无名只待春","socials":{"github":"https://github.com/JeryLiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/243662531"},"jianshu":{"icon":"/svg/jianshu.svg","link":"https://www.jianshu.com/u/f1275d68d75d"}}}},"mapped":true,"prev_post":{"title":"消息队列(二)——技术选型","uid":"2772ec5587279a800698d9e5d832844d","slug":"消息队列-二-——技术选型","date":"2019-12-09T12:51:17.000Z","updated":"2021-08-16T12:50:56.831Z","comments":true,"path":"api/articles/消息队列-二-——技术选型.json","keywords":null,"cover":"../img/MQ/cover2.png","text":"在了解了消息队列的常用场景后，我们考虑接下来的选型问题。如今使用较多的消息队列有ActiveMQ、RabbitMQ、ZeroMQ、Kafka、MetaMQ、RocketMQ等，以及部分数据库如Redis也可以实现消息队列功能。我们该选择哪一种来引入我们的项目中呢？那么接下来，主要...","link":"","photos":[],"count_time":{"symbolsCount":"5.8k","symbolsTime":"5 mins."},"categories":[{"name":"MQ","slug":"MQ","count":3,"path":"api/categories/MQ.json"}],"tags":[{"name":"MQ选型","slug":"MQ选型","count":1,"path":"api/tags/MQ选型.json"}],"author":{"name":"安安哎呀呀","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/img_convert/71d174e6f2050f828d65a741734d6e0c.png","link":"/","description":"山内有樱名为良，树本无名只待春","socials":{"github":"https://github.com/JeryLiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/243662531"},"jianshu":{"icon":"/svg/jianshu.svg","link":"https://www.jianshu.com/u/f1275d68d75d"}}}},"feature":true},"next_post":{"title":"Mysql主从复制(二)--原理、时延等问题解决","uid":"e2de674c94d8362ed71699d8daa90a57","slug":"Mysql主从复制-二-原理、时延等问题解决","date":"2020-08-22T06:55:47.000Z","updated":"2021-07-01T08:24:57.376Z","comments":true,"path":"api/articles/Mysql主从复制-二-原理、时延等问题解决.json","keywords":null,"cover":"../img/Mysql/cover2.jpeg","text":"前言在上一篇MySQL主从复制（一）——实战文章中，我们简单的提了一下它的实现原理，随后即开始了其相关的实现实战内容。在本篇文章中，我们主要详细了解数据库主从复制的实现原理以及其在同步过程中存在的时延问题。 1. 主从复制的形式 一主一从 主主复制 一主多从：扩展系统读取的性能，...","link":"","photos":[],"count_time":{"symbolsCount":"4k","symbolsTime":"4 mins."},"categories":[{"name":"Database","slug":"Database","count":3,"path":"api/categories/Database.json"}],"tags":[{"name":"Mysql","slug":"Mysql","count":3,"path":"api/tags/Mysql.json"}],"author":{"name":"安安哎呀呀","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/img_convert/71d174e6f2050f828d65a741734d6e0c.png","link":"/","description":"山内有樱名为良，树本无名只待春","socials":{"github":"https://github.com/JeryLiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/243662531"},"jianshu":{"icon":"/svg/jianshu.svg","link":"https://www.jianshu.com/u/f1275d68d75d"}}}}}}