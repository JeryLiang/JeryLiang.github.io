{"title":"Nginx详解","uid":"d8b4487bc85f218a66607245054b2ebc","slug":"Nginx详解","date":"2019-03-19T06:52:16.000Z","updated":"2021-07-01T07:37:02.977Z","comments":true,"path":"api/articles/Nginx详解.json","keywords":null,"cover":"../img/Nginx详解/cover.jpeg","content":"<h1 id=\"nginx详解\"><a href=\"#nginx详解\" class=\"headerlink\" title=\"nginx详解\"></a>nginx详解</h1><h4 id=\"一、什么是正向代理和反向代理？\"><a href=\"#一、什么是正向代理和反向代理？\" class=\"headerlink\" title=\"一、什么是正向代理和反向代理？\"></a>一、什么是正向代理和反向代理？</h4><hr>\n<ul>\n<li><p>正向代理</p>\n<p>  <img src=\"../img/Nginx%E8%AF%A6%E8%A7%A3/1.png\" alt=\"image\"> </p>\n<ul>\n<li>  反向代理</li>\n</ul>\n<p>   <img src=\"../img/Nginx%E8%AF%A6%E8%A7%A3/2.png\" alt=\"image\"> </p>\n</li>\n</ul>\n<p><strong>URI、URL和URN</strong>:</p>\n<ul>\n<li><p>  URI ：Uniform Resource Identifier，统一资源标识符；</p>\n</li>\n<li><p>  URL：Uniform Resource Locator，统一资源定位符；</p>\n</li>\n<li><p>  URN：Uniform Resource Name，统一资源名称。</p>\n</li>\n</ul>\n<p> <img src=\"../img/Nginx%E8%AF%A6%E8%A7%A3/3.png\" alt=\"image\"> </p>\n<ul>\n<li><p>  URL主要由三部分组成：第一部分是协议(或成为服务方式)，第二部分是存有该资源的主机IP地址(有时也包括端口号)，第三部分是主机资源的具体地址，如目录和文件夹名等。</p>\n</li>\n<li><p>  URI和URL都定义了资源是什么，但URL是一种具体的URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。URI 是一种语义上的抽象概念，可以是绝对的，也可以是相对的，而URL则必须提供足够的信息来定位，是绝对的。</p>\n</li>\n</ul>\n<h4 id=\"二、nginx负载均衡策略\"><a href=\"#二、nginx负载均衡策略\" class=\"headerlink\" title=\"二、nginx负载均衡策略\"></a>二、nginx负载均衡策略</h4><hr>\n<p>nginx服务器负载均衡策略可以划分为两大类：</p>\n<p>1.内置策略</p>\n<ul>\n<li><p>  <strong>轮询</strong>：将每个前端请求按顺序（时间顺序或者排列顺序）逐一分配到不同的后端节点上，对于出现问题的后端节点自动排除；</p>\n</li>\n<li><p>  <strong>加权轮询</strong>：在轮询的基础上加上weight，指定各后端节点被轮询到的几率；</p>\n</li>\n<li><p>  <strong>IP_hash</strong>：将前端访问的IP进行hash操作，然后根据hash结果将请求分配给不同的后端节点上。注：同一IP经过hash的出来的值是一样的，即请求固定落在hash后选择的那台后端服务器上。</p>\n</li>\n</ul>\n<p>2.扩展策略</p>\n<ul>\n<li><p>  <strong>url_hash</strong>：对前端访问的url进行hash操作。（若后端服务器异常，不能自动排除该节点）</p>\n</li>\n<li><p>  <strong>fair</strong>：将请求转发到一个最近负载最小的后台节点。如何判断负载最小？Nginx通过后端节点对请求的响应时间来判断负载的情况。响应时间短的节点负载相对较轻。</p>\n</li>\n</ul>\n<h4 id=\"三、nginx基本配置详解\"><a href=\"#三、nginx基本配置详解\" class=\"headerlink\" title=\"三、nginx基本配置详解\"></a>三、nginx基本配置详解</h4><hr>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">##### **1.nginx.conf**:\n\nworker_processes 1;\nerror_log  &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;logs&#x2F;nginx_error.log;\npid &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;nginx.pid;\nevents&#123;\n worker_connections 1024;\n&#125;\n​\nhttp&#123;\n include mime.types;\n default_type application&#x2F;octet-stream;\n\n sendfile on;\n keepalive_timeout 65;\n\n upstream  back&#123;\n server address weight&#x3D;2 max_fails&#x3D;5 fail_timeout&#x3D;30s;\n server address weight&#x3D;1 max_fails&#x3D;5 fail_timeout&#x3D;30s;\n ip_hash;\n &#125;\n\n server&#123;\n listen 80;\n server_name localhost;\n\n location &#x2F; &#123;\n index index.html index.php;\n root &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;html;\n &#125;\n\n location ~ &#x2F;api&#x2F;1.0&#x2F;ll&#x2F;(.*) &#123;\n proxy_pass http:&#x2F;&#x2F;back; # 设置被代理服务器地址\n proxy_set_header Host $host;\n proxy_set_header X-Real-IP $remote_addr;\n proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n &#125;\n\n error_page 404      &#x2F;404.html;\n error_page 500 502 503 504 &#x2F;50x.html;\n location &#x3D; &#x2F;50x.html&#123;\n root html;\n &#125;\n &#125;\n\n&#125;</code></pre>\n\n<h5 id=\"2-upstream-中server指令语法如下：\"><a href=\"#2-upstream-中server指令语法如下：\" class=\"headerlink\" title=\"2.upstream 中server指令语法如下：\"></a><strong>2.upstream 中server指令语法如下</strong>：</h5><p>server address [parameters] 注： 关键字server为必选项，address也为必选项，可以是主机名、域名、ip或  unix socket，也可以指定端口号；  ​  parameters是可选参数，可以是如下参数：</p>\n<ul>\n<li><p>  down：将server标记为宕机状态；</p>\n</li>\n<li><p>  backup：将组内服务器标记为备用服务器，只有当正常的服务器处于宕机状态或则繁忙状态时，该服务器才会被用来处理客户端请求；</p>\n</li>\n<li><p>  weight：表示server的负载权重，权重越大被请求的几率越大，默认为1；</p>\n</li>\n<li><p>  fail_timeout：请求时间超过这个值时，认定其为请求失败，此时断开连接，默认值为10s；</p>\n</li>\n<li><p>  max_fails：设置一个请求失败的次数，在一定范围时间内（即fail_timeout时间内），当对组内某台服务器请求失败的次数超过该变量设置的值时，认为该服务器无效，默认值是1(即默认情况下只要发生错误就认为server宕机了)；</p>\n</li>\n<li><p>  fail_timeout和max_fails通常联合使用：如果某台server在fail_timeout时间内出现了max_fails次连接失败，那么Nginx会认为该server已经宕机，从而在fail_timeout时间内不会再去请求这台server。</p>\n<h4 id=\"3-location用法：\"><a href=\"#3-location用法：\" class=\"headerlink\" title=\"3.location用法：\"></a>3.location用法：</h4><p>location 模式| 含义</p>\n</li>\n</ul>\n<p>—|—<br>以 = 开头|表示精准匹配，如只匹配根目录结尾的请求，后面不能带任何字符串<br>以 ^~ 开头|表示uri以某个常规字符串开头，不是正则匹配<br>以 ~ 开头|表示区分大小写的正则匹配<br>以 ~* 开头|表示不区分大小写的正则匹配<br>以 / 开头|通用匹配, 如果没有其它匹配,任何请求都会匹配到</p>\n<p> 1)精准匹配 /，主机名后面不能带任何字符串</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">location &#x3D; &#x2F; &#123;\n      [configuration A]\n&#125;</code></pre>\n<p>2)通用匹配，所有地址都以/开头，所以这条规则将会在最后匹配，即默认请求</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\"> location &#x2F; &#123;\n    [configuration B]\n&#125;</code></pre>\n<p>3)匹配以 /test/ 开头的地址，匹配符合以后，还要继续往下搜索。只有后面的正则表达式没有匹配到时，这一条才会采用（该普通匹配遵循最长匹配规则），即若uri为/test/mine/则会采用第二条的配置</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">location &#x2F;test&#x2F; &#123;\n  [configuration C]\n&#125;\nlocation &#x2F;test&#x2F;mine&#x2F; &#123;\n #配置\n&#125;</code></pre>\n<p>4)匹配任何以/images/开头的地址，匹配符合以后，停止往下搜索正则</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">location ^~ &#x2F;images&#x2F; &#123;\n  [configuration D]\n&#125;</code></pre>\n<p>5)匹配所有以gif、jpg或jpeg结尾的请求。需要注意的是，若配置了4中的配置，则/images/下的图片都只会被配置D处理，因为^~不再往下搜索</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">location ~* \\.(gif|jpg|jpeg)$ &#123;\n  [configuration E]\n&#125;</code></pre>\n<p>6）各匹配顺序优先级如下</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">(location &#x3D;) &gt; (location 完整路径) &gt; (location ^~ 路径)&gt; (location ~,~*正则顺序) &gt; (location 部分起始路径) &gt; (&#x2F;)</code></pre>\n<p>7)测试时的configuration推荐使用以下配置来测试，可以配置不同的rewrite网址来达到测试效果,如下所示。在浏览器中输入ip+端口号/test/即可测试匹配是否成功。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">location &#x2F;test&#x2F; &#123;\n   rewrite ^ https:&#x2F;&#x2F;jeryliang.github.io&#x2F;;\n&#125;</code></pre>\n<p>8)若使用location来实现访问静态文件的话，有以下需要注意的地方</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">例：该例子就是访问nginx默认的index.html\n默认配置为：\nlocation &#x2F; &#123;\nindex index.html;\nroot &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;html;\n&#125;\n修改后的配置：\nlocation &#x2F;html&#x2F; &#123;\n index index.html;\n root &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;; \n&#125;\n</code></pre>\n<p>以上两个配置都能实现访问nginx默认的index.html。这是为什么呢？修改后的配置通过请求ip:port/html/也可以访问，是因为匹配字符串html会和root指定路径进行拼接，实际的拼接后的路径为/usr/local/nginx/html。<br>而默认的其实也是拼接的，只不过匹配字符串为/，拼接后和原始/usr/local/nginx/html是一样的，所以访问到了index.html。</p>\n<h5 id=\"4-nginx中的rewrite实现域名跳转\"><a href=\"#4-nginx中的rewrite实现域名跳转\" class=\"headerlink\" title=\"4.nginx中的rewrite实现域名跳转\"></a><strong>4.nginx中的rewrite实现域名跳转</strong></h5><p>在开始讲述rewrite功能前，需要搞清楚”地址重写”和”地址转发”两个概念。（注：rewrite功能依赖于PCRE库）</p>\n<ul>\n<li><p>  地址重写：其实也就是地址重定向，例：输入google.cn访问谷歌时，在被服务器重定向为<a href=\"www.google.com\">www.google.com</a>的过程就是地址重定向的过程，此时浏览器的地址会变为<a href=\"www.google.com\">www.google.com</a>；</p>\n</li>\n<li><p>  地址转发：是指一个域名指指到另一个已有站点的过程。</p>\n</li>\n</ul>\n<p>这两者的主要区别如下：</p>\n<ul>\n<li><p>  地址转发后客户端浏览器地址栏中的地址是不会改变的，而地址重写后的客户端浏览器地址栏中的地址改变为服务器选择确定的地址；</p>\n</li>\n<li><p>  在一次地址转发过程中，只产生一次网络请求，而地址重写一般会产生两次或两次以上的请求；</p>\n</li>\n<li><p>  地址转发的速度比地址重定向快。</p>\n</li>\n</ul>\n<p>rewrite可以在server块或者location块中配置，以下为几个例子：</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\"># 例1：域名跳转\nserver &#123;\n listen 80;\n server_name liang.jerry.com;\n rewrite ^&#x2F; http:&#x2F;&#x2F;www.jerry.info&#x2F;;\n&#125;\n# 例2：多域名跳转\nserver &#123;\n listen 80;\n server_name  liang.jerry.name  liang.jerry.info;\n index index.htm index.php;\n root &#x2F;usr&#x2F;local&#x2F;html;\n if($host  ~ jerry\\.info)&#123;    # $host的值中是否包含(其中~对大小写敏感)jerry.info字符串，若                             #包含则为真\n rewrite ^(.*) http:&#x2F;&#x2F;liang.jerry.name&#x2F;$1 permanent; \n #^为匹配字符串的开始，（.*）匹配任意字符，permanent表示返回301永久重定向，地址栏会显示跳转后的地址；\n &#125;\n&#125;\n# 例3：三级域名跳转\nserver &#123;\n listen 80;\n server_name liang1.jerry.name liang2.jerry.name;\n # ~*对字母大小写不敏感，若$http_host中包含 任意字符.jerry.name字符串，则为真\n if($host ~*  ^(.*)\\.jerry\\.name$)&#123;\n rewrite ^(.*) http:&#x2F;&#x2F;liang.jerry.name$1;\n break; # 此处break目的在于重定向后不再进行location的匹配（即后续的其他rewrite），\n &#125;\n&#125;</code></pre>\n\n\n<h4 id=\"5-rewrite常用正则\"><a href=\"#5-rewrite常用正则\" class=\"headerlink\" title=\"5.rewrite常用正则\"></a>5.rewrite常用正则</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">.  匹配除换行符以外的任意字符\n？ 重复0次或1次\n+  重复1次或更多次\n*  重复0次或更多次\n\\d 匹配数字\n^  匹配字符串的开始\n$  匹配字符串的结束\n&#123;n&#125; 重复n次\n&#123;n,&#125; 重复n次或更多次\n[c]  匹配单个字符c\n[a-z] 匹配a-z小写字母的任意一个\n小括号()之间匹配的内容，可以在后面通过$1来引用，$2表示的是前面第二个()里的内容，同时还有转义字符\\</code></pre>\n\n<h5 id=\"5-反向代理服务需要注意的细节\"><a href=\"#5-反向代理服务需要注意的细节\" class=\"headerlink\" title=\"5.反向代理服务需要注意的细节\"></a>5.反向代理服务需要注意的细节</h5><p><strong>proxy_pass</strong>指令，先看如下例子：</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\"># 例1\nupstream  proxy_svrs &#123;\n server http:&#x2F;&#x2F;192.168.1.1:8088&#x2F;uri&#x2F;;\n server http:&#x2F;&#x2F;192.168.1.1:8088&#x2F;uri&#x2F;;\n server http:&#x2F;&#x2F;192.168.1.1:8088&#x2F;uri&#x2F;;\n&#125;\nserver &#123;\n listen 80;\n server_name www.jerry.com;\n location &#x2F; &#123;\n proxy_pass  proxy_svrs;\n &#125;\n&#125;\n# 例2\nupstream proxy_svrs &#123;\n server 192.168.1.1:8088&#x2F;uri&#x2F;;\n server 192.168.1.1:8088&#x2F;uri&#x2F;;\n server 192.168.1.1:8088&#x2F;uri&#x2F;;\n&#125;\nserver &#123;\n listen 80;\n server_name www.jerry.com;\n location &#x2F; &#123;\n proxy_pass  http:&#x2F;&#x2F;proxy_svrs;\n &#125;\n&#125;</code></pre>\n\n<p>即在服务器组中已经指明了传输协议”http://“时，proxy_pass中就不需要指明，反之，要在proxy_pass中指明。</p>\n<p>需要注意的是如下的情况：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">server proxy_svrs &#123;\n listen 80;\n server_name www.jerry.com;\n location &#x2F;server&#x2F; &#123;\n proxy_pass http:&#x2F;&#x2F;192.168.1.2&#x2F;jerry&#x2F;;\n &#125;\n&#125;</code></pre>\n\n<p>在这配置的情况下，假如客户端发起的请求为<a href=\"http://www.jerry.com/server/\">http://www.jerry.com/server/</a>，Nginx会把地址转向”<a href=\"http://192.168.1.2/jerry/\">http://192.168.1.2/jerry/</a>“。所以，在使用proxy_pass代理的时候，如果不想改变原有地址中的URI，就不要在URL中配置URI。同时，需要注意的是”/“同样是作为URI，如<a href=\"http://192.168.1.2/\">http://192.168.1.2</a>和<a href=\"http://182.168.1.2/\">http://182.168.1.2/</a>是有区别的，若代理的URL中包含URI，第二种会替换掉原有URL中的URI。如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">server &#123;\n listen 80;\n server_name www.jerry.com;\n location &#x2F;server&#x2F; &#123;\n # 配置1:   proxy_pass  http:&#x2F;&#x2F;192.168.1.2;\n # 配置2:   proxy_pass  http:&#x2F;&#x2F;192.168.1.2&#x2F;;\n &#125;\n&#125;</code></pre>\n\n<p><strong>proxy_set_header指令</strong></p>\n<p>该指令可以更改Nginx服务器接收到的客户端请求的请求头信息，然后将新的请求头发送给被代理的服务器。其语法结构为：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">proxy_set_header field value；\n# field为要更改的信息所在的头域；\n# value为更改的值，支持使用文本、变量或者变量的组合\n#例1\nproxy_set_header Host $http_host; #将目前Host头域的值填充成客户端的地址\nproxy_set_header Host $host; #将当前location块的server_name指令值填充到Host头域</code></pre>\n\n<p><strong>proxy_http_version指令</strong></p>\n<p>该指令用于设置Nginx服务器提供代理服务的HTTP协议版本，默认设置为1.0版本。1.1版本支持upstream服务器组设置中的keepalive指令。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">proxy_http_version 1.0  | 1.1;</code></pre>\n<h4 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h4><ul>\n<li><p>  location、rewrite规则：<a href=\"https://www.cnblogs.com/dadonggg/p/7797281.html\">https://www.cnblogs.com/dadonggg/p/7797281.html</a></p>\n</li>\n<li><p>  《nginx高性能web服务器详解》</p>\n</li>\n</ul>\n","text":"nginx详解一、什么是正向代理和反向代理？ 正向代理 反向代理 URI、URL和URN: URI ：Uniform Resource Identifier，统一资源标识符； URL：Uniform Resource Locator，统一资源定位符； URN：Uniform Re...","link":"","photos":[],"count_time":{"symbolsCount":"7.4k","symbolsTime":"7 mins."},"categories":[{"name":"Devops","slug":"Devops","count":4,"path":"api/categories/Devops.json"}],"tags":[{"name":"Nginx","slug":"Nginx","count":1,"path":"api/tags/Nginx.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#nginx%E8%AF%A6%E8%A7%A3\"><span class=\"toc-text\">nginx详解</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%EF%BC%9F\"><span class=\"toc-text\">一、什么是正向代理和反向代理？</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5\"><span class=\"toc-text\">二、nginx负载均衡策略</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%89%E3%80%81nginx%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3\"><span class=\"toc-text\">三、nginx基本配置详解</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-upstream-%E4%B8%ADserver%E6%8C%87%E4%BB%A4%E8%AF%AD%E6%B3%95%E5%A6%82%E4%B8%8B%EF%BC%9A\"><span class=\"toc-text\">2.upstream 中server指令语法如下：</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-location%E7%94%A8%E6%B3%95%EF%BC%9A\"><span class=\"toc-text\">3.location用法：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-nginx%E4%B8%AD%E7%9A%84rewrite%E5%AE%9E%E7%8E%B0%E5%9F%9F%E5%90%8D%E8%B7%B3%E8%BD%AC\"><span class=\"toc-text\">4.nginx中的rewrite实现域名跳转</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-rewrite%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99\"><span class=\"toc-text\">5.rewrite常用正则</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#5-%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E7%BB%86%E8%8A%82\"><span class=\"toc-text\">5.反向代理服务需要注意的细节</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83\"><span class=\"toc-text\">参考</span></a></li></ol></li></ol></li></ol></li></ol>","author":{"name":"安安哎呀呀","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"山内有樱名为良，树本无名只待春","socials":{"github":"https://github.com/JeryLiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/243662531"},"jianshu":{"icon":"/svg/jianshu.svg","link":"https://www.jianshu.com/u/f1275d68d75d"}}}},"mapped":true,"prev_post":{"title":"Springboot整合redis","uid":"09e2399cbd512aa4be49b295beddf488","slug":"Springboot整合redis","date":"2019-03-21T06:52:34.000Z","updated":"2021-07-01T07:47:58.856Z","comments":true,"path":"api/articles/Springboot整合redis.json","keywords":null,"cover":"../img/Springboot整合redis/cover.jpeg","text":"####一、redis服务器安装与配置1.redis安装 #下载相应相应的tar.gz包 wget http:&#x2F;&#x2F;download.redis.io&#x2F;releases&#x2F;redis-5.0.3.tar.gz #解压 tar -zxvf red...","link":"","photos":[],"count_time":{"symbolsCount":"4.9k","symbolsTime":"4 mins."},"categories":[{"name":"Java","slug":"Java","count":7,"path":"api/categories/Java.json"}],"tags":[{"name":"redis","slug":"redis","count":2,"path":"api/tags/redis.json"},{"name":"springboot","slug":"springboot","count":2,"path":"api/tags/springboot.json"}],"author":{"name":"安安哎呀呀","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"山内有樱名为良，树本无名只待春","socials":{"github":"https://github.com/JeryLiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/243662531"},"jianshu":{"icon":"/svg/jianshu.svg","link":"https://www.jianshu.com/u/f1275d68d75d"}}}}},"next_post":{"title":"Springboot超详细搭建过程","uid":"aaca0be6401ddc4b6b987223429803e8","slug":"Springboot超详细搭建过程","date":"2019-03-17T07:00:41.000Z","updated":"2021-07-01T07:30:11.008Z","comments":true,"path":"api/articles/Springboot超详细搭建过程.json","keywords":null,"cover":"../img/Springboot超详细搭建过程/cover.jpeg","text":"一、创建篇 新建项目，如下图所示。 选择Spring Initializr。 填写Group、Artifact和Name后点击next，如下图所示。 选择需要的组件：基本组件有web模块中的web和web server、SQL模块中的MySQL、JDBC和Mybatis、额外的组...","link":"","photos":[],"count_time":{"symbolsCount":"3.5k","symbolsTime":"3 mins."},"categories":[{"name":"Java","slug":"Java","count":7,"path":"api/categories/Java.json"}],"tags":[{"name":"springboot","slug":"springboot","count":2,"path":"api/tags/springboot.json"}],"author":{"name":"安安哎呀呀","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"山内有樱名为良，树本无名只待春","socials":{"github":"https://github.com/JeryLiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/243662531"},"jianshu":{"icon":"/svg/jianshu.svg","link":"https://www.jianshu.com/u/f1275d68d75d"}}}}}}