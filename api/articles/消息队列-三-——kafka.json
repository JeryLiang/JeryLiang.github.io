{"title":"消息队列(三)——kafka","uid":"1a334e4ba9c2396d196ceadace888870","slug":"消息队列-三-——kafka","date":"2019-12-09T12:24:28.000Z","updated":"2021-08-16T12:54:23.830Z","comments":true,"path":"api/articles/消息队列-三-——kafka.json","keywords":null,"cover":"../img/MQ/cover3.png","content":"<p>在通过消息队列（一）与消息队列（二），相信大家已经对消息队列的几大应用场景，以及各大消息队列中间件的优缺点，那么我们接下来将要讲述的是分布式发布订阅消息系统——kafka的一些相关概念与术语的介绍。</p>\n<h4 id=\"1、简介\"><a href=\"#1、简介\" class=\"headerlink\" title=\"1、简介\"></a>1、简介</h4><hr>\n<h5 id=\"1-1-概述\"><a href=\"#1-1-概述\" class=\"headerlink\" title=\"1.1 概述\"></a>1.1 概述</h5><hr>\n<p>Kafka是最初由Linkedin公司开发，是一种高吞吐量的分布式发布订阅消息系统，常见可以用于web/nginx日志、访问日志，消息服务等，Linkedin于2010年贡献给了Apache基金会并成为顶级开源项目。</p>\n<p>Kafka主要设计目标如下：</p>\n<ul>\n<li>以时间复杂度为O(1)的方式提供消息持久化能力，即使对TB级以上数据也能保证常数时间的访问性能；</li>\n<li>高吞吐率。即使在非常廉价的商用机器上也能做到单机支持每秒100K条消息的传输；</li>\n<li>支持Kafka Server间的消息分区，及分布式消费，同时保证每个partition内的消息顺序传输；</li>\n<li>同时支持离线数据处理和实时数据处理；</li>\n<li>Scale out:支持在线水平扩展。</li>\n</ul>\n<h5 id=\"1-2-消息传递模式\"><a href=\"#1-2-消息传递模式\" class=\"headerlink\" title=\"1.2 消息传递模式\"></a>1.2 消息传递模式</h5><hr>\n<p>常见的消息传递模式有两种、分别是：</p>\n<ul>\n<li><code>点对点传递模式</code>：在点对点消息系统中，消息持久化到一个队列中。此时，可以有一个后多个消费者消费队列中的数据，但是一条消息只能被消费一次。当一个消费者消费了队列中的某条数据之后，该条数据则从消息队列中删除。该模式下，既有多个消费者同时消费数据，也能保证数据处理的顺序。如下图所示。</li>\n</ul>\n<p><img src=\"../img/MQ/3-1.png\" alt=\"点对点传递模式\"></p>\n<ul>\n<li><code>发布-订阅消息传递模式</code>：在发布-订阅消息系统中，消息将被持久化到一个topic中，与点对点消息系统的区别是，消费者可以订阅一个或多个topic，消费者可以消费该topic中所有的数据，同一条数据可以被多个消费者消费，且数据消费后不会立马删除，且发布者发送到topic中的消息，只有订阅了topic的订阅者才会收到。在发布-订阅消息系统中，消息的生产者成为发布者，消费者称为订阅者。如下图所示。</li>\n</ul>\n<p><img src=\"../img/MQ/3-2.png\" alt=\"发布订阅模式\"></p>\n<h4 id=\"2、kafka中常用的术语\"><a href=\"#2、kafka中常用的术语\" class=\"headerlink\" title=\"2、kafka中常用的术语\"></a>2、kafka中常用的术语</h4><hr>\n<p>我们通过下图的kafka简单示例架构来熟悉kafka中的术语。</p>\n<p><img src=\"../img/MQ/3-3.png\" alt=\"Kafka架构示例\"></p>\n<p>我们先解释图中出现的术语，最后再对整个图的内容做一个详细解释。</p>\n<h5 id=\"2-1-Topic\"><a href=\"#2-1-Topic\" class=\"headerlink\" title=\"2.1 Topic\"></a>2.1 Topic</h5><hr>\n<p>每天发布到Kafka集群的消息都有一个主题类别，这个主题类别称为<code>Topic</code>。物理上不同的Topic的消息可能存储在同一broker中，也有可能不在同一broker中，但逻辑上只要用户指定消息的topic即可消费关于该topic<br>的有关数据，而不必关心数据的物理存储。</p>\n<h5 id=\"2-2-Partition\"><a href=\"#2-2-Partition\" class=\"headerlink\" title=\"2.2 Partition\"></a>2.2 Partition</h5><hr>\n<p>Topic中的数据分割为一个或多个分区（<code>partition</code>）。partition有以下特性：</p>\n<ul>\n<li>每个Topic至少有一个partition；</li>\n<li>每个partition中的数据使用多个segment文件存储；</li>\n<li>partition中的数据是有序的，而不同partition间的数据丢失了数据的顺序（即我们无法知道哪个partition的数据是最先的或最后的）；</li>\n<li>如果topic有多个partition，消费数据时就不能保证数据的顺序。因此，在需要严格保证消息的消费顺序的场景下，需要将partition的数目设置为1。</li>\n</ul>\n<h5 id=\"2-3-Broker\"><a href=\"#2-3-Broker\" class=\"headerlink\" title=\"2.3 Broker\"></a>2.3 Broker</h5><hr>\n<p>在上图中我们可以在<code>Kafka Cluster</code>（即kafka集群）中看到，集群里包含了一个或多个服务器，这些服务器节点称为<code>Broker</code>。Broker存储着topic的数据，常见的存储数据方式如下：</p>\n<ul>\n<li>如果某topic有N个partition，集群有N个Broker，那么每个Broker存储该topic的一个partition；</li>\n<li>如果某topic有N个partition，集群有N+M个Broker，那么其中有N个broker存储该topic的一个partition，剩下的M个Broker不存储该topic的partition数据；</li>\n<li>如果某topic有N个partition，集群的Broker数目少于N个，那么一个Broker存储该topic的一个或多个partition。（<code>注意</code>：在实际生产环境中，一般会尽量避免这种情况发生，因为这种情况容易导致Kafka集群数据不均衡）。</li>\n</ul>\n<h5 id=\"2-4-Producer\"><a href=\"#2-4-Producer\" class=\"headerlink\" title=\"2.4 Producer\"></a>2.4 Producer</h5><hr>\n<p><code>Producer</code>即数据的发布者，该角色将消息发布到Kafka的topic中。Broker接收到生产者发送的消息后，将该消息<code>追加</code>到当前用于追加数据的segment文件中。生产者发送的消息，可以存储到每一个partition中，也可以指定数据存储的partition。</p>\n<h5 id=\"2-5-Consumer\"><a href=\"#2-5-Consumer\" class=\"headerlink\" title=\"2.5 Consumer\"></a>2.5 Consumer</h5><hr>\n<p><code>Consumer</code>即为消费数据的一方，消费者可以从Broker中读取数据。消费者可以消费多个topic中的数据。</p>\n<h5 id=\"2-6-Offset\"><a href=\"#2-6-Offset\" class=\"headerlink\" title=\"2.6 Offset\"></a>2.6 Offset</h5><hr>\n<p><code>Offset</code>即偏移量（位置），标识分区每条记录的位置，是分区当中每条记录的唯一标识。消费者通过记录当前消费到的偏移量来记录消费情况。</p>\n<p><img src=\"../img/MQ/3-4.png\" alt=\"偏移量\"></p>\n<h5 id=\"2-6-Consumer-Group\"><a href=\"#2-6-Consumer-Group\" class=\"headerlink\" title=\"2.6 Consumer Group\"></a>2.6 Consumer Group</h5><hr>\n<p><code>Consumer Group</code>即为消费者组，用于占用式消费。我们可以为每个Consumer指定Group name，若不指定Group name则属于默认的Group。消费者组有以下特性：</p>\n<ul>\n<li>对于同一个topic的同一个partition，消费者消费时，会按消费者组来记录消费偏移，即一个组内只维护一个消费偏移。假设消费者1和消费者2同属一组，消费者1消费了一部分数据，那么消费者2此时再来消费数据的话，是无法消费到消费者1消费了的那部分数据的。如下图：</li>\n</ul>\n<p><img src=\"../img/MQ/3-5.png\" alt=\"消费者组消费示例\"></p>\n<ul>\n<li>不同的group之间记录不同的offset，这样在不同程序读取同一个topic时，才不会因为offset互相影响。 </li>\n</ul>\n<h5 id=\"2-7-Leader\"><a href=\"#2-7-Leader\" class=\"headerlink\" title=\"2.7 Leader\"></a>2.7 Leader</h5><hr>\n<p>每个partition有多个副本，其中<code>有且仅有</code>一个作为<code>Leader</code>，Leader是当前负责数据读写的partition。</p>\n<h5 id=\"2-8-Follower\"><a href=\"#2-8-Follower\" class=\"headerlink\" title=\"2.8 Follower\"></a>2.8 Follower</h5><p><code>Follower</code>跟随Leader，即与Leader数据保持一致。其特性如下：</p>\n<ul>\n<li>所有写请求都通过Leader来路由，即Leader数据的变更会广播给所有Follwer；</li>\n<li>Follwer与Leader保持数据同步；</li>\n<li>如果Leader失效，则从Follower中选举出一个新的Leader；</li>\n<li>当Follower挂掉、卡住或同步太慢，Leader会把这个Follower从”in sync replicas”(ISR)列表中删除，重新创建一个Follower。</li>\n</ul>\n<h5 id=\"2-8-架构示例图详细解释\"><a href=\"#2-8-架构示例图详细解释\" class=\"headerlink\" title=\"2.8 架构示例图详细解释\"></a>2.8 架构示例图详细解释</h5><hr>\n<p><img src=\"../img/MQ/3-6.png\" alt=\"Kafka架构示例\"></p>\n<ul>\n<li>我们可以看到，图中主要分为四个部分。分别是<code>Producer</code>、<code>Kafka Cluster</code>、<code>Consumer Group</code>和<code>Zookeeper注册中心</code>；</li>\n<li>Producer中有两个生产者A和B。Kafka Cluster中有3个Broker（即3台服务器）。Consumer Group中有3个消费者，其中1和2消费者属于同一个消费者组，消费者3属于默认消费者组。Zookeeper主要负责统一管理Kafka Cluster中的所有注册的Broker、消费者组中的消费者；</li>\n<li> 某个主题消息（Topic A）设置了两个分区，分别是<code>partition 0</code>与<code>partition 1</code>，每个partition都有其备份分区。其中存储在Broker 1中的partition 0为partition 0的Leader（生产者生产消息与消费者消费消息时主要是与Leader交互），partition 0的备份存储在Broker 2中（图中绿色部分）。存储在Broker 2中的partition 1为partition 1的Leader，partition 1的备份存储在Broker 1中（图中浅蓝色部分）；</li>\n<li>首先，最左边的是两个生产者A、B。生产者A生产了<code>message-A</code>这个消息，将消息分别发送至两个partition的Leader中。生产者B将生产的消息发送到只有一个分区的Topic B的partition 0分区中。</li>\n<li>然后在消费阶段，Consumer 1消费Topic A的partition 0中的消息。Consumer 2由于和Consumer 1属于一个消费者组（对相同partition属于占用式消费，但消费不同partition时可以同时进行消费），所以此时Consumer 2可以消费Topic A的partition 1中的消息。Consumer 3 消费Topic B中的partition 0中的消息。 </li>\n</ul>\n","feature":true,"text":"在通过消息队列（一）与消息队列（二），相信大家已经对消息队列的几大应用场景，以及各大消息队列中间件的优缺点，那么我们接下来将要讲述的是分布式发布订阅消息系统——kafka的一些相关概念与术语的介绍。 1、简介 1.1 概述 Kafka是最初由Linkedin公司开发，是一种高吞吐...","link":"","photos":[],"count_time":{"symbolsCount":"3.4k","symbolsTime":"3 mins."},"categories":[{"name":"MQ","slug":"MQ","count":3,"path":"api/categories/MQ.json"}],"tags":[{"name":"kafka","slug":"kafka","count":1,"path":"api/tags/kafka.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1%E3%80%81%E7%AE%80%E4%BB%8B\"><span class=\"toc-text\">1、简介</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-1-%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">1.1 概述</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-2-%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">1.2 消息传递模式</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2%E3%80%81kafka%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%9C%AF%E8%AF%AD\"><span class=\"toc-text\">2、kafka中常用的术语</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-1-Topic\"><span class=\"toc-text\">2.1 Topic</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-2-Partition\"><span class=\"toc-text\">2.2 Partition</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-3-Broker\"><span class=\"toc-text\">2.3 Broker</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-4-Producer\"><span class=\"toc-text\">2.4 Producer</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-5-Consumer\"><span class=\"toc-text\">2.5 Consumer</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-6-Offset\"><span class=\"toc-text\">2.6 Offset</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-6-Consumer-Group\"><span class=\"toc-text\">2.6 Consumer Group</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-7-Leader\"><span class=\"toc-text\">2.7 Leader</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-8-Follower\"><span class=\"toc-text\">2.8 Follower</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-8-%E6%9E%B6%E6%9E%84%E7%A4%BA%E4%BE%8B%E5%9B%BE%E8%AF%A6%E7%BB%86%E8%A7%A3%E9%87%8A\"><span class=\"toc-text\">2.8 架构示例图详细解释</span></a></li></ol></li></ol>","author":{"name":"安安哎呀呀","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/img_convert/71d174e6f2050f828d65a741734d6e0c.png","link":"/","description":"山内有樱名为良，树本无名只待春","socials":{"github":"https://github.com/JeryLiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/243662531"},"jianshu":{"icon":"/svg/jianshu.svg","link":"https://www.jianshu.com/u/f1275d68d75d"}}}},"mapped":true,"prev_post":{"title":"消息队列(二)——技术选型","uid":"2772ec5587279a800698d9e5d832844d","slug":"消息队列-二-——技术选型","date":"2019-12-09T12:51:17.000Z","updated":"2021-08-16T12:50:56.831Z","comments":true,"path":"api/articles/消息队列-二-——技术选型.json","keywords":null,"cover":"../img/MQ/cover2.png","text":"在了解了消息队列的常用场景后，我们考虑接下来的选型问题。如今使用较多的消息队列有ActiveMQ、RabbitMQ、ZeroMQ、Kafka、MetaMQ、RocketMQ等，以及部分数据库如Redis也可以实现消息队列功能。我们该选择哪一种来引入我们的项目中呢？那么接下来，主要...","link":"","photos":[],"count_time":{"symbolsCount":"5.8k","symbolsTime":"5 mins."},"categories":[{"name":"MQ","slug":"MQ","count":3,"path":"api/categories/MQ.json"}],"tags":[{"name":"MQ选型","slug":"MQ选型","count":1,"path":"api/tags/MQ选型.json"}],"author":{"name":"安安哎呀呀","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/img_convert/71d174e6f2050f828d65a741734d6e0c.png","link":"/","description":"山内有樱名为良，树本无名只待春","socials":{"github":"https://github.com/JeryLiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/243662531"},"jianshu":{"icon":"/svg/jianshu.svg","link":"https://www.jianshu.com/u/f1275d68d75d"}}}},"feature":true},"next_post":{"title":"消息队列(一)——消息队列的应用场景","uid":"96ba06db63c23312ef17859b33c16987","slug":"消息队列-一-——消息队列的应用场景","date":"2019-12-06T08:32:24.000Z","updated":"2021-08-16T12:40:35.607Z","comments":true,"path":"api/articles/消息队列-一-——消息队列的应用场景.json","keywords":null,"cover":"../img/MQ/cover1.png","text":"1. 什么是消息队列 队列相信大家应该都不陌生，它是一种先进先出的数据结构，基本结构如下图。 在java中已经实现了各种各样的队列了，那为什么还需要消息队列MQ（Message Queue）这种中间件呢？我们可以先尝试思考一下消息队列存在的意义，它能满足我们项目中的什么需求，下面...","link":"","photos":[],"count_time":{"symbolsCount":"2.4k","symbolsTime":"2 mins."},"categories":[{"name":"MQ","slug":"MQ","count":3,"path":"api/categories/MQ.json"}],"tags":[{"name":"MQ应用场景","slug":"MQ应用场景","count":1,"path":"api/tags/MQ应用场景.json"}],"author":{"name":"安安哎呀呀","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/img_convert/71d174e6f2050f828d65a741734d6e0c.png","link":"/","description":"山内有樱名为良，树本无名只待春","socials":{"github":"https://github.com/JeryLiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/243662531"},"jianshu":{"icon":"/svg/jianshu.svg","link":"https://www.jianshu.com/u/f1275d68d75d"}}}},"feature":true}}