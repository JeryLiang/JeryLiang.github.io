{"title":"Mysql主从复制(二)--原理、时延等问题解决","uid":"e2de674c94d8362ed71699d8daa90a57","slug":"Mysql主从复制-二-原理、时延等问题解决","date":"2020-08-22T06:55:47.000Z","updated":"2021-07-01T08:24:57.376Z","comments":true,"path":"api/articles/Mysql主从复制-二-原理、时延等问题解决.json","keywords":null,"cover":"../img/Mysql/cover2.jpeg","content":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><p>在上一篇<a href=\"https://www.jianshu.com/p/4541a68d16d7\">MySQL主从复制（一）——实战</a>文章中，我们简单的提了一下它的实现原理，随后即开始了其相关的实现实战内容。在本篇文章中，我们主要详细了解数据库主从复制的实现原理以及其在同步过程中存在的时延问题。</p>\n<h4 id=\"1-主从复制的形式\"><a href=\"#1-主从复制的形式\" class=\"headerlink\" title=\"1. 主从复制的形式\"></a>1. 主从复制的形式</h4><ul>\n<li>一主一从</li>\n<li>主主复制</li>\n<li>一主多从：扩展系统读取的性能，因为读是在从库读取的；</li>\n<li>多主一从：MySQL5.7开始支持；</li>\n<li>联级复制</li>\n</ul>\n<h4 id=\"2-主从复制实现原理\"><a href=\"#2-主从复制实现原理\" class=\"headerlink\" title=\"2. 主从复制实现原理\"></a>2. 主从复制实现原理</h4><p><img src=\"../img/Mysql/1.png\" alt=\"主从复制原理图\"></p>\n<p>简单来讲，其过程为</p>\n<ul>\n<li>主库的任何数据更改都会被记录到<code>二进制日志(binlog)</code>中；</li>\n<li>从库生成两个线程，一个<code>I/O线程</code>，一个<code>SQL线程</code>；</li>\n<li>I/O线程去请求主库 的binlog，并将得到的binlog日志写到<code>relay log（中继日志）</code> 文件中；</li>\n<li>主库会生成一个 <code>log dump 线程</code>，用来给从库 I/O线程传binlog；</li>\n<li>SQL 线程，会读取relay log文件中的日志，从Exec_Master_Log_Pos位置开始执行读取到的更新事件，将更新内容写入到slave的db，来实现主从的操作一致，而最终数据一致；</li>\n</ul>\n<p>我们可以发现从库同步主库数据的过程是串行化的，也就是说主库上并行的操作，在从库上会串行执行，由于从库从主库拷贝日志以及串行执行 SQL 的特点，在高并发场景下，从库的数据一定会比主库慢一些，是有延时的。所以经常出现，刚写入主库的数据可能是读不到的，要过几十毫秒，甚至几百毫秒才能读取到。这就是我们接下来要谈到的<code>主从同步时延问题</code>。</p>\n<h4 id=\"3-主从同步时延问题的产生\"><a href=\"#3-主从同步时延问题的产生\" class=\"headerlink\" title=\"3.主从同步时延问题的产生\"></a>3.主从同步时延问题的产生</h4><p>时延问题可能会导致我们新增的数据无法读取到，我们针对业务的不同情况来决定我们是否允许有时延，若不允许，则需要我们进行相应的配置去解决。</p>\n<h5 id=\"3-1-时延情况观察\"><a href=\"#3-1-时延情况观察\" class=\"headerlink\" title=\"3.1 时延情况观察\"></a>3.1 时延情况观察</h5><p>我们在配置好的从库上执行<code> show slave status\\G;</code>可以看到如下参数：</p>\n<ul>\n<li><code>Master_Log_File</code>： SLAVE中的I/O线程当前正在读取的主服务器二进制日志文件的名称；</li>\n<li><code>Read_Master_Log_Pos</code>： 在当前的主服务器二进制日志中，SLAVE中的I/O线程已经读取的位置；</li>\n<li><code>Relay_Log_File</code>： SQL线程当前正在读取和执行的中继日志文件的名称；</li>\n<li><code>Relay_Log_Pos</code>： 在当前的中继日志中，SQL线程已读取和执行的位置；</li>\n<li><code>Relay_Master_Log_File</code>： 由SQL线程执行的包含多数近期事件的主服务器二进制日志文件的名称；</li>\n<li><code>Slave_IO_Running</code>： I/O线程是否被启动并成功地连接到主服务器上;</li>\n<li><code>Slave_SQL_Running</code>： SQL线程是否被启动；</li>\n<li><code>Seconds_Behind_Master</code>： 从属服务器SQL线程和从属服务器I/O线程之间的时间差距，单位以秒计。</li>\n</ul>\n<p>从以上的参数中，我们可以观察得知主从数据库的时延情况：</p>\n<ul>\n<li>从库同步延迟情况出现的<code>Seconds_Behind_Master</code>不为0，这个数值可能会很大；</li>\n<li><code>Relay_Master_Log_File</code>和<code>Master_Log_File</code>显示bin-log的编号相差很大，说明bin-log在从库上没有及时同步，所以近期执行的bin-log和当前IO线程所读的bin-log相差很大；</li>\n<li>MySQL的从库数据目录下存在大量mysql-relay-log日志，该日志同步完成之后就会被系统自动删除，存在大量日志，说明主从同步延迟很高。</li>\n</ul>\n<h5 id=\"3-2-主从同步延时问题的产生\"><a href=\"#3-2-主从同步延时问题的产生\" class=\"headerlink\" title=\"3.2 主从同步延时问题的产生\"></a>3.2 主从同步延时问题的产生</h5><p>1）MySQL数据库主从同步延迟原理：主库针对写操作，顺序写binlog，从库单线程去主库顺序读”写操作的binlog”，从库取到binlog在本地原样执行（随机写），来保证主从数据逻辑上一致。mysql的主从复制都是单线程的操作，主库对所有DDL和DML产生binlog，binlog是顺序写，所以效率很高，slave的Slave_IO_Running线程到主库取日志，效率比较高，下一步，问题来了，slave的Slave_SQL_Running线程将主库的DDL和DML操作在slave实施。DML和DDL的IO操作是随即的，不是顺序的，成本高很多，还可能可slave上的其他查询产生lock争用，由于Slave_SQL_Running也是单线程的，所以一个DDL卡主了，需要执行10分钟，那么所有之后的DDL会等待这个DDL执行完才会继续执行，这就导致了延时。有朋友会问：“主库上那个相同的DDL也需要执行10分，为什么slave会延时？”，答案是master可以并发，Slave_SQL_Running线程却不可以。</p>\n<p>2）MySQL数据库主从同步延迟是怎么产生的？当主库的TPS并发较高时，产生的DDL数量超过slave一个sql线程所能承受的范围，那么延时就产生了，当然还有就是可能与slave的大型query语句产生了锁等待。首要原因：数据库在业务上读写压力太大，CPU计算负荷大，网卡负荷大，硬盘随机IO太高次要原因：读写binlog带来的性能影响，网络传输延迟。</p>\n<h4 id=\"4-主从同步时延问题解决\"><a href=\"#4-主从同步时延问题解决\" class=\"headerlink\" title=\"4. 主从同步时延问题解决\"></a>4. 主从同步时延问题解决</h4><p>在讲解时延问题解决时，我们先大概了解MySql主从复制存在的问题：</p>\n<ul>\n<li><code>主库宕机后，数据可能丢失</code>；</li>\n<li><code>从库只有一个sql thread，在主库写压力大的时候，复制可能存在时延</code>；</li>\n</ul>\n<h5 id=\"4-1-MySql提供的几种主从复制机制：\"><a href=\"#4-1-MySql提供的几种主从复制机制：\" class=\"headerlink\" title=\"4.1 MySql提供的几种主从复制机制：\"></a>4.1 MySql提供的几种主从复制机制：</h5><p>(1)<code>异步复制</code>：MYSQL 默认的复制方式，就是主库写入binlog日志后即可成功返回客户端，无须等待binlog日志传递给从库的过程。但这样一旦主库发生宕机，就有可能出现数据丢失的情况。<br>(2）<code>半同步复制(mysql semi-sync)</code>，解决数据丢失的问题，其原理如下：</p>\n<ul>\n<li>事务在主库写完binlog后需要从库返回一个已接受，才返回给客户端。简单的讲就是，主库写入 binlog 日志之后，就会将强制此时立即将数据同步到从库，从库将日志写入自己本地的 relay log 之后，接着会返回一个 ack 给主库，主库接收到至少一个从库的 ack 之后才会认为写操作完成了</li>\n<li>5.5集成到mysql，以插件的形式存在，需要单独安装；</li>\n<li>确保事务提交后binlog至少传输到一个从库 ；</li>\n<li>不保证从库应用完这个事务的binlog；</li>\n<li>性能有一定的降低，响应时间会更长；</li>\n<li>网络异常或从库宕机，卡主主库，直到超时或从库恢复；</li>\n</ul>\n<p>(3)<code>并行复制</code>，解决从库复制延迟的问题，指的是从库开启多个线程，并行读取 relay log 中不同库的日志，然后并行重放不同库的日志，这是库级别的并行。其特点如下：</p>\n<ul>\n<li>5.6中新增；</li>\n<li>并行是指从库多线程apply binlog ；</li>\n<li>库级别并行应用binlog，同一个库数据更改还是串行的(5.7版并行复制基于事务组)设置set global slave_parallel_workers=10;设置sql线程数为10；</li>\n</ul>\n<h5 id=\"4-2-时延问题解决\"><a href=\"#4-2-时延问题解决\" class=\"headerlink\" title=\"4.2 时延问题解决\"></a>4.2 时延问题解决</h5><ul>\n<li><p>分库，将一个主库拆分为多个主库，每个主库的写并发就减少了几倍，此时主从延迟可以忽略不计。</p>\n</li>\n<li><p>打开 MySQL 支持的并行复制，多个库并行复制。如果说某个库的写入并发就是特别高，单库写并发达到了 2000/s，并行复制还是没意义。<br>针对主从延迟，本人的经验如下：</p>\n</li>\n<li><p><code> 业务量不大的</code>：主库能处理业务就全放在主库吧，从库只做灾备，备份，对实时性要求不高的统计报表类工作；</p>\n</li>\n<li><p><code>已经出现延迟的</code>：一般来说，就慢慢等吧，试图通过重启db之类的操作是无法解决的，还会因为大事务回滚再重做导致花的时间更长；</p>\n</li>\n<li><p><code>延迟N天无法解决的</code>：那就重做slave。为什么会延迟N天，难道仅仅是因为从库单线程吗？我感觉大部分都是主库上采用mixed的binlog_format，由于某种限制，无法基于statement，只好row模式复制。那么如果当前sql是全表扫描，传到slave上执行时就是茫茫多次的全表扫描了。一般来说在slave上show proceslist看查看当前的system user正在执行什么，那就是问题SQL。如果pos点一直不动，也可以去主库对应的binlog上查看下执行的是什么东西；</p>\n</li>\n<li><p><code>出现延迟时，查看下当前slave的cpu和磁盘状况</code>：一般来说如果从库没有其他业务，单线程的原因，cpu跑满一个核已经是极限了。磁盘io满的话，确认下是否有其他进程或mysql线程影响了它(比如从库正在dump或者超大的sql在执行)，也可以尝试调整下slave上关于io的几个参数；</p>\n</li>\n<li><p><code>从库raid卡，务必设置成write back的写策略</code>；</p>\n</li>\n<li><p><code>批量的dml操作</code>：批量的dml操作如果不做处理，一般必然会出现延迟，建议业务低峰期执行，并将批量操作做下调整，一次dml 10000行，sleep一会，再dml 10000行。具体的行数和sleep需要自己根据业务确定，能保证从库不延迟就好；</p>\n</li>\n<li><p>如果还是经常性的短时间延迟，那就尝试加大从库的硬件配置，比如上sata  SSD，pcie等</p>\n</li>\n<li><p><code>延迟的监控到位</code>，可通过pt-heart-beat来准确监控延迟值，及时发现查看。</p>\n</li>\n<li><p>5.5以后版本的，可以考虑<code>采用半同步复制</code>，能解决少量延迟引起的问题，不过对<code>tps性能损耗较大</code>；</p>\n</li>\n<li><p>升级到mysql 5.7吧，<code>多线程复制</code>即<code>并行复制</code>，几乎完美解决单线程复制引起的从库延迟。</p>\n</li>\n</ul>\n<h4 id=\"5-总结\"><a href=\"#5-总结\" class=\"headerlink\" title=\"5. 总结\"></a>5. 总结</h4><p>总的来说，我们可以根据业务场景的不同，合理的选择是否主从复制后再结合读写分离，因为读写分离，是必须要面对时延这一问题，我们可以根据我们需求来确定到底是不是真的需要读写分离，因为我们也同样可以利用redis缓存，或者其它缓存来缓解我们数据库的压力，而将从库仅作为我们的备份，这样我们就不需要去保证从库无时延(即数据与主库实时同步)，所以具体的应用需要符合我们自己的业务场景。</p>\n","feature":true,"text":"前言在上一篇MySQL主从复制（一）——实战文章中，我们简单的提了一下它的实现原理，随后即开始了其相关的实现实战内容。在本篇文章中，我们主要详细了解数据库主从复制的实现原理以及其在同步过程中存在的时延问题。 1. 主从复制的形式 一主一从 主主复制 一主多从：扩展系统读取的性能，...","link":"","photos":[],"count_time":{"symbolsCount":"4k","symbolsTime":"4 mins."},"categories":[{"name":"Database","slug":"Database","count":3,"path":"api/categories/Database.json"}],"tags":[{"name":"Mysql","slug":"Mysql","count":3,"path":"api/tags/Mysql.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%89%8D%E8%A8%80\"><span class=\"toc-text\">前言</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E5%BD%A2%E5%BC%8F\"><span class=\"toc-text\">1. 主从复制的形式</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">2. 主从复制实现原理</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E6%97%B6%E5%BB%B6%E9%97%AE%E9%A2%98%E7%9A%84%E4%BA%A7%E7%94%9F\"><span class=\"toc-text\">3.主从同步时延问题的产生</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-1-%E6%97%B6%E5%BB%B6%E6%83%85%E5%86%B5%E8%A7%82%E5%AF%9F\"><span class=\"toc-text\">3.1 时延情况观察</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-2-%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E5%BB%B6%E6%97%B6%E9%97%AE%E9%A2%98%E7%9A%84%E4%BA%A7%E7%94%9F\"><span class=\"toc-text\">3.2 主从同步延时问题的产生</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E6%97%B6%E5%BB%B6%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3\"><span class=\"toc-text\">4. 主从同步时延问题解决</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-1-MySql%E6%8F%90%E4%BE%9B%E7%9A%84%E5%87%A0%E7%A7%8D%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%9C%BA%E5%88%B6%EF%BC%9A\"><span class=\"toc-text\">4.1 MySql提供的几种主从复制机制：</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-2-%E6%97%B6%E5%BB%B6%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3\"><span class=\"toc-text\">4.2 时延问题解决</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">5. 总结</span></a></li></ol>","author":{"name":"安安哎呀呀","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"山内有樱名为良，树本无名只待春","socials":{"github":"https://github.com/JeryLiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/243662531"},"jianshu":{"icon":"/svg/jianshu.svg","link":"https://www.jianshu.com/u/f1275d68d75d"}}}},"mapped":true,"prev_post":{},"next_post":{"title":"如何设计风格良好的Restful API","uid":"4ad927e9758be2d736a1a9cb9de5ab88","slug":"如何设计风格良好的Restful-API","date":"2019-12-04T14:56:30.000Z","updated":"2021-08-13T08:40:29.430Z","comments":true,"path":"api/articles/如何设计风格良好的Restful-API.json","keywords":null,"cover":"../img/RESTful/cover.png","text":"最近朋友们都在讨论项目Api规范的问题，大家对Restful风格的Api都或多或少有所了解，但是没人能明确说明Restful到底是什么情况下才能认为是Restful，比如说下面的这类代码算Restful 嘛？ @RequestMapping(value &#x3D; &quot;...","link":"","photos":[],"count_time":{"symbolsCount":"5.7k","symbolsTime":"5 mins."},"categories":[{"name":"RestfulApi","slug":"RestfulApi","count":1,"path":"api/categories/RestfulApi.json"}],"tags":[{"name":"RestfulApi","slug":"RestfulApi","count":1,"path":"api/tags/RestfulApi.json"}],"author":{"name":"安安哎呀呀","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"山内有樱名为良，树本无名只待春","socials":{"github":"https://github.com/JeryLiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/243662531"},"jianshu":{"icon":"/svg/jianshu.svg","link":"https://www.jianshu.com/u/f1275d68d75d"}}}},"feature":true}}