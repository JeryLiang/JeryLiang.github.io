{"title":"如何设计风格良好的Restful API","uid":"4ad927e9758be2d736a1a9cb9de5ab88","slug":"如何设计风格良好的Restful-API","date":"2019-12-04T14:56:30.000Z","updated":"2021-08-13T08:40:29.430Z","comments":true,"path":"api/articles/如何设计风格良好的Restful-API.json","keywords":null,"cover":"../img/RESTful/cover.png","content":"<p>最近朋友们都在讨论项目Api规范的问题，大家对Restful风格的Api都或多或少有所了解，但是没人能明确说明Restful到底是什么情况下才能认为是Restful，比如说下面的这类代码算Restful 嘛？</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">@RequestMapping(value &#x3D; &quot;&#x2F;addUser&quot;, method &#x3D; RequestMethod.POST)\n   public boolean updateUser( User user) &#123;\n       return userService.updateUser(user);\n   &#125;</code></pre>\n<p>初步的觉得存在的问题是，Restful一般url中表示的应该是一种资源，而不是动作+资源这种形式，为此它不是Restful风格的API。当时的疑问是，如果我用user来定义一个资源，再通过动作来判定是更新还是修改，那样的话岂不是每种资源都会有四种类型的接口。然而，在Restful风格的设计中确实是这样的。通过这种方式可以让我们很清楚的知道该API的一个具体实现效果是什么，以及操作的是哪类资源。第一部分介绍Restful API的相关规范，第二部分是具体的实践部分，参考<a href=\"https://www.jianshu.com/p/d6424d98b02e\">https://www.jianshu.com/p/d6424d98b02e</a>宅楠军的文章，在他的基础上，结合mybatis + lombok 实现Restful风格的设计。</p>\n<h4 id=\"1-Restful-API的相关概念\"><a href=\"#1-Restful-API的相关概念\" class=\"headerlink\" title=\"1 Restful API的相关概念\"></a>1 Restful API的相关概念</h4><h5 id=\"1-1-版本\"><a href=\"#1-1-版本\" class=\"headerlink\" title=\"1.1 版本\"></a>1.1 版本</h5><hr>\n<p>API的版本应该在URL中体现，如：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">https:&#x2F;&#x2F;api.jerry.com&#x2F;v1&#x2F;</code></pre>\n<p>另一种做法是，将版本号放在HTTP头信息中，但没有放在URL中那么直观。</p>\n<h5 id=\"1-2-路径\"><a href=\"#1-2-路径\" class=\"headerlink\" title=\"1.2 路径\"></a>1.2 路径</h5><hr>\n<p>路径又称”终点”(endpoint)，表示API的具体网址。<br>在Restful架构中，每一种网址代表一种资源（resource），所有网址中不能有动词，只能有名词，而且所有名词往往与数据库的表名一致，且API中的名词也应该用复数。示例如下：</p>\n<ul>\n<li><code>https://api.jerry.com/v1/zoos</code></li>\n<li><code>https://api.jerry.com/v1/animals</code></li>\n<li><code>https://api.jerry.com/v1/employees</code></li>\n</ul>\n<h5 id=\"1-3-HTTP动词\"><a href=\"#1-3-HTTP动词\" class=\"headerlink\" title=\"1.3 HTTP动词\"></a>1.3 HTTP动词</h5><hr>\n<p>对于资源的具体操作类型，由HTTP动词表示。<br>常用的HTTP动词有如下五个（括号里是对应的SQL类型）</p>\n<ul>\n<li><code> GET（SELECT）</code>：从服务器取出资源（一项或多项）；</li>\n<li><code> POST（CREATE）</code>：在服务器新建一个资源；</li>\n<li><code>PUT（UPDATE）</code>：在服务器更新资源（客户端提供改变后的完整资源）；</li>\n<li><code>PATCH（UPDATE）</code>：在服务器更新资源（客户端提供改变的属性）；</li>\n<li><code>DELETE（DELETE）</code>：从服务器删除资源。</li>\n</ul>\n<p>还有两个不常用的HTTP动词：</p>\n<ul>\n<li><code>HEAD</code>：获取资源的元数据；</li>\n<li><code>OPTIONS</code>：获取信息，关于资源的哪些属性是客户端可以改变的；</li>\n</ul>\n<p>动词使用示例：</p>\n<ul>\n<li><code>GET /zoos</code>：列出所有动物园</li>\n<li><code>POST /zoos</code>：新建一个动物园</li>\n<li><code>GET /zoos/ID</code>：获取某个指定动物园的信息</li>\n<li><code>PUT /zoos/ID</code>：更新某个指定动物园的信息（提供该动物园的全部信息）</li>\n<li><code>PATCH /zoos/ID</code>：更新某个指定动物园的信息（提供该动物园的部分信息）</li>\n<li><code>DELETE /zoos/ID</code>：删除某个动物园</li>\n<li><code>GET /zoos/ID/animals</code>：列出某个指定动物园的所有动物</li>\n<li><code>DELETE /zoos/ID/animals/ID</code>：删除某个指定动物园的指定动物</li>\n</ul>\n<h5 id=\"1-4-过滤信息（Filtering）\"><a href=\"#1-4-过滤信息（Filtering）\" class=\"headerlink\" title=\"1.4 过滤信息（Filtering）\"></a>1.4 过滤信息（Filtering）</h5><hr>\n<p>如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供响应的参数来过滤返回的结果。常见参数示例如下：</p>\n<ul>\n<li><code>?limit=5</code>：指定返回的记录的数量；</li>\n<li><code>?offset=10</code> ：指定返回记录的开始位置；</li>\n<li><code>?page=2&amp;per_page=100</code>：指定第几页，以及每页的记录数;</li>\n<li><code>?sortby=name&amp;order=asc</code>：指定返回结果按照哪个属性排序，以及排序顺序;</li>\n<li><code>?animal_type_id=1</code>：指定筛选条件。<br>参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复。比如，<code>GET /zoo/ID/animals</code> 与<code>GET /animals?zoo_id=ID</code>的含义是相同的。</li>\n</ul>\n<h5 id=\"1-5-状态码（Status-Codes）\"><a href=\"#1-5-状态码（Status-Codes）\" class=\"headerlink\" title=\"1.5 状态码（Status Codes）\"></a>1.5 状态码（Status Codes）</h5><hr>\n<p>服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）。</p>\n<ul>\n<li><code>200 OK - [GET]</code>：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。</li>\n<li><code> 201 CREATED - [POST/PUT/PATCH]</code>：用户新建或修改数据成功。</li>\n<li><code>202 Accepted - [*]</code>：表示一个请求已经进入后台排队（异步任务）</li>\n<li><code>204 NO CONTENT - [DELETE]</code>：用户删除数据成功。</li>\n<li><code>400 INVALID REQUEST - [POST/PUT/PATCH]</code>：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。</li>\n<li><code>401 Unauthorized - [*]</code>：表示用户没有权限（令牌、用户名、密码错误）。</li>\n<li><code>403 Forbidden - [*] </code>:表示用户得到授权（与401错误相对），但是访问是被禁止的。</li>\n<li><code>404 NOT FOUND - [*]</code>：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。</li>\n<li><code>406 Not Acceptable - [GET]</code>：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。</li>\n<li><code>410 Gone -[GET]</code>：用户请求的资源被永久删除，且不会再得到的。</li>\n<li><code>422 Unprocesable entity - [POST/PUT/PATCH] </code>当创建一个对象时，发生一个验证错误。</li>\n<li><code>500 INTERNAL SERVER ERROR - [*]</code>：服务器发生错误，用户将无法判断发出的请求是否成功。</li>\n</ul>\n<h5 id=\"1-6-错误处理（Error-handling）\"><a href=\"#1-6-错误处理（Error-handling）\" class=\"headerlink\" title=\"1.6 错误处理（Error handling）\"></a>1.6 错误处理（Error handling）</h5><hr>\n<p>如果状态码是4xx，就应该向用户返回出错信息。一般来说，返回的信息中将error作为键名，出错信息作为键值即可。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#123;\n    error: &quot;Invalid API key&quot;\n&#125;</code></pre>\n<h5 id=\"1-7-返回结果\"><a href=\"#1-7-返回结果\" class=\"headerlink\" title=\"1.7 返回结果\"></a>1.7 返回结果</h5><hr>\n<p>针对不同操作，服务器向用户返回的结果应该符合以下规范。</p>\n<ul>\n<li><code>GET /collection</code>：返回资源对象的列表（数组）</li>\n<li><code>GET /collection/resource</code>：返回单个资源对象</li>\n<li><code>POST /collection</code>：返回新生成的资源对象</li>\n<li><code>PUT /collection/resource</code>：返回完整的资源对象</li>\n<li><code>PATCH /collection/resource</code>：返回完整的资源对象</li>\n<li><code>DELETE /collection/resource</code>：返回一个空文档</li>\n</ul>\n<h4 id=\"2-Restful-Api-设计\"><a href=\"#2-Restful-Api-设计\" class=\"headerlink\" title=\"2 Restful  Api 设计\"></a>2 Restful  Api 设计</h4><p><a href=\"https://www.jianshu.com/p/d6424d98b02e\">https://www.jianshu.com/p/d6424d98b02e</a>宅楠军的文章整体项目搭建过程已经讲的很详细了，在他的基础上，我没使用jpa来实现与数据库交互，而是使用的mybatis，使用mybatis可以很方便的解决宅男军文章3.2中提到的空值问题，我们不考虑复制的问题，而是通过在mapperxml中的动态SQL来实现空值的判定，具体代码如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;\n&lt;!DOCTYPE mapper PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot; &gt;\n&lt;mapper namespace&#x3D;&quot;com.jerry.restful.mapper.UserMapper&quot;&gt;\n    &lt;resultMap id&#x3D;&quot;userList&quot; type&#x3D;&quot;com.jerry.restful.domain.User&quot;&gt;\n        &lt;id column&#x3D;&quot;id&quot; property&#x3D;&quot;id&quot; jdbcType&#x3D;&quot;INTEGER&quot;&#x2F;&gt;\n        &lt;result column&#x3D;&quot;user_name&quot; property&#x3D;&quot;userName&quot; jdbcType&#x3D;&quot;VARCHAR&quot;&#x2F;&gt;\n        &lt;result column&#x3D;&quot;account&quot; property&#x3D;&quot;account&quot; jdbcType&#x3D;&quot;VARCHAR&quot;&#x2F;&gt;\n        &lt;result column&#x3D;&quot;password&quot; property&#x3D;&quot;password&quot; jdbcType&#x3D;&quot;VARCHAR&quot;&#x2F;&gt;\n        &lt;result column&#x3D;&quot;age&quot; property&#x3D;&quot;age&quot; jdbcType&#x3D;&quot;INTEGER&quot;&#x2F;&gt;\n    &lt;&#x2F;resultMap&gt;\n\n    &lt;update id&#x3D;&quot;updateUser&quot;&gt;\n        UPDATE t_user\n        SET\n        &lt;if test&#x3D;&quot;user.account !&#x3D; null&quot;&gt;\n            account &#x3D; #&#123;user.account&#125;,\n        &lt;&#x2F;if&gt;\n        &lt;if test&#x3D;&quot;user.userName !&#x3D; null&quot;&gt;\n            user_name &#x3D; #&#123;user.userName&#125;,\n        &lt;&#x2F;if&gt;\n        &lt;if test&#x3D;&quot;user.password !&#x3D; null&quot;&gt;\n            password &#x3D; #&#123;user.password&#125;,\n        &lt;&#x2F;if&gt;\n        &lt;if test&#x3D;&quot;user.age !&#x3D; null&quot;&gt;\n            age &#x3D; #&#123;user.age&#125;\n        &lt;&#x2F;if&gt;\n        WHERE id &#x3D; id\n\n    &lt;&#x2F;update&gt;\n&lt;&#x2F;mapper&gt;\n</code></pre>\n<p>而使用lombok的目的是使实体类的代码更简洁，如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Data\npublic class User &#123;\n\n    private Integer id;\n\n    private String userName;\n\n    private Integer age;\n\n    private String account;\n\n    private String password;\n\n    public User()&#123;&#125;\n\n&#125;\n</code></pre>\n<h5 id=\"项目中用到的部分注解解释\"><a href=\"#项目中用到的部分注解解释\" class=\"headerlink\" title=\"项目中用到的部分注解解释\"></a>项目中用到的部分注解解释</h5><p>spring注解:</p>\n<ul>\n<li><code>@GetMapping</code>：等同于@RequestMapping(method = RequestMethod.GET)，其他类似；</li>\n<li><code>@PostMapping</code> : 同上，只是动作变成了POST；</li>\n<li><code>@DeleteMapping</code>：同上；</li>\n<li><code>@PutMapping</code>：同上；</li>\n<li><code>@pathVariable</code> ：获取URL变量；</li>\n<li><code>@RequestBody</code> ：将request body中的Json/xml对象解析成该参数类型的Javabean对象；</li>\n<li><code>@RequestParam</code>：获取前端传递给后端的参数，其中如果前端传递的参数和后端要接收的参数名字一致的，可以省略不写，如果不一致一定要完整写，不然获取不到想要的值。</li>\n</ul>\n<p>swagger注解：<br><code>@ApiOperation</code>：接口说明注解；<br><code>@ApiParam</code>：解释api的参数的含义；</p>\n<p>本文改进源码链接：<a href=\"https://github.com/JeryLiang/Restful-API-Demo\">https://github.com/JeryLiang/Restful-API-Demo</a></p>\n<h4 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h4><p>阮一峰大神的文章<a href=\"http://www.ruanyifeng.com/blog/2014/05/restful_api.html\">《RESTful API 设计指南》</a><br><a href=\"https://www.jianshu.com/p/d6424d98b02e\">https://www.jianshu.com/p/d6424d98b02e</a>宅楠军的文章</p>\n","feature":true,"text":"最近朋友们都在讨论项目Api规范的问题，大家对Restful风格的Api都或多或少有所了解，但是没人能明确说明Restful到底是什么情况下才能认为是Restful，比如说下面的这类代码算Restful 嘛？ @RequestMapping(value &#x3D; &quot;...","link":"","photos":[],"count_time":{"symbolsCount":"5.7k","symbolsTime":"5 mins."},"categories":[{"name":"RestfulApi","slug":"RestfulApi","count":1,"path":"api/categories/RestfulApi.json"}],"tags":[{"name":"RestfulApi","slug":"RestfulApi","count":1,"path":"api/tags/RestfulApi.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-Restful-API%E7%9A%84%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">1 Restful API的相关概念</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-1-%E7%89%88%E6%9C%AC\"><span class=\"toc-text\">1.1 版本</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-2-%E8%B7%AF%E5%BE%84\"><span class=\"toc-text\">1.2 路径</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-3-HTTP%E5%8A%A8%E8%AF%8D\"><span class=\"toc-text\">1.3 HTTP动词</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-4-%E8%BF%87%E6%BB%A4%E4%BF%A1%E6%81%AF%EF%BC%88Filtering%EF%BC%89\"><span class=\"toc-text\">1.4 过滤信息（Filtering）</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-5-%E7%8A%B6%E6%80%81%E7%A0%81%EF%BC%88Status-Codes%EF%BC%89\"><span class=\"toc-text\">1.5 状态码（Status Codes）</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-6-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%EF%BC%88Error-handling%EF%BC%89\"><span class=\"toc-text\">1.6 错误处理（Error handling）</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-7-%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C\"><span class=\"toc-text\">1.7 返回结果</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-Restful-Api-%E8%AE%BE%E8%AE%A1\"><span class=\"toc-text\">2 Restful  Api 设计</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%94%A8%E5%88%B0%E7%9A%84%E9%83%A8%E5%88%86%E6%B3%A8%E8%A7%A3%E8%A7%A3%E9%87%8A\"><span class=\"toc-text\">项目中用到的部分注解解释</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83\"><span class=\"toc-text\">参考</span></a></li></ol>","author":{"name":"安安哎呀呀","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"山内有樱名为良，树本无名只待春","socials":{"github":"https://github.com/JeryLiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/243662531"},"jianshu":{"icon":"/svg/jianshu.svg","link":"https://www.jianshu.com/u/f1275d68d75d"}}}},"mapped":true,"prev_post":{"title":"Mysql主从复制(二)--原理、时延等问题解决","uid":"e2de674c94d8362ed71699d8daa90a57","slug":"Mysql主从复制-二-原理、时延等问题解决","date":"2020-08-22T06:55:47.000Z","updated":"2021-07-01T08:24:57.376Z","comments":true,"path":"api/articles/Mysql主从复制-二-原理、时延等问题解决.json","keywords":null,"cover":"../img/Mysql/cover2.jpeg","text":"前言在上一篇MySQL主从复制（一）——实战文章中，我们简单的提了一下它的实现原理，随后即开始了其相关的实现实战内容。在本篇文章中，我们主要详细了解数据库主从复制的实现原理以及其在同步过程中存在的时延问题。 1. 主从复制的形式 一主一从 主主复制 一主多从：扩展系统读取的性能，...","link":"","photos":[],"count_time":{"symbolsCount":"4k","symbolsTime":"4 mins."},"categories":[{"name":"Database","slug":"Database","count":3,"path":"api/categories/Database.json"}],"tags":[{"name":"Mysql","slug":"Mysql","count":3,"path":"api/tags/Mysql.json"}],"author":{"name":"安安哎呀呀","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"山内有樱名为良，树本无名只待春","socials":{"github":"https://github.com/JeryLiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/243662531"},"jianshu":{"icon":"/svg/jianshu.svg","link":"https://www.jianshu.com/u/f1275d68d75d"}}}},"feature":true},"next_post":{"title":"JSON Web Token","uid":"6025476afb5f5063e34d3c43d435967b","slug":"JSON-Web-Token","date":"2019-07-23T04:07:07.000Z","updated":"2021-08-13T08:34:34.576Z","comments":true,"path":"api/articles/JSON-Web-Token.json","keywords":null,"cover":"../img/JWT/cover.png","text":"相信大家或多或少都接触过这个场景，那就是我们注册某个一个网站长账号后(账号A)，网站会给我们的注册邮箱发送一封邮件，其中包含了激活链接，一般情况下，这个链接会在几个小时内过期，过期后就无法激活了。同样，你并不能使用这个激活链接来激活你又新注册的一个账号(此处称为账号B)。 JWT...","link":"","photos":[],"count_time":{"symbolsCount":"10k","symbolsTime":"9 mins."},"categories":[{"name":"Java","slug":"Java","count":8,"path":"api/categories/Java.json"}],"tags":[{"name":"jwt","slug":"jwt","count":1,"path":"api/tags/jwt.json"}],"author":{"name":"安安哎呀呀","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"山内有樱名为良，树本无名只待春","socials":{"github":"https://github.com/JeryLiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/243662531"},"jianshu":{"icon":"/svg/jianshu.svg","link":"https://www.jianshu.com/u/f1275d68d75d"}}}},"feature":true}}