{"title":"Docker","uid":"a48e6dda0c21e40880cba7e763278b04","slug":"Docker","date":"2018-11-24T06:15:13.000Z","updated":"2021-08-13T07:56:07.687Z","comments":true,"path":"api/articles/Docker.json","keywords":null,"cover":"../img/Docker/cover.jpeg","content":"<h4 id=\"什么是Docker\"><a href=\"#什么是Docker\" class=\"headerlink\" title=\"什么是Docker?\"></a><strong>什么是Docker?</strong></h4><hr>\n<p>Docker是基于Go语言实现的云开源项目。Docker的主要目标是“<strong>Build，Ship and Run Any App,Anywhere</strong>”，也就是通过对应用组件的封装、分发、部署、运行等生命周期的管理，使用户的APP（可以是一个WEB应用或者数据库应用等等）及其运行环境能够做到“<strong>一次封装，到处运行</strong>”。</p>\n<p>Docker引擎的基础是Linux自带的容器（Linux Containers,LXC）技术。IBM对于容器技术的准确描述如下：</p>\n<p><strong>容器有效的将单个操作系统管理的资源划分到孤立的组中，以便更好的在孤立的组之间平衡有冲突的资源使用需求</strong>。与虚拟化相比，这样既不需要指令级模拟，也不需要即时编译。容器可以在核心CPU本地运行指令，而不需要任何专门的解释机制。此外，也避免了准虚拟化（paravirtualization）和系统调用替换中的复杂性。</p>\n<p>我们可以将容器理解为一种沙盒。每个容器内运行一个应用，不同的容器相互隔离，容器之间可以建立通信机制。容器的创建和停止都十分快速（秒级），容器自身对资源的需求十分有限，远比虚拟机本身占用的资源少。</p>\n<h4 id=\"Docker结构\"><a href=\"#Docker结构\" class=\"headerlink\" title=\"Docker结构\"></a><strong>Docker结构</strong></h4><hr>\n<p><img src=\"../img/Docker/1.png\" alt=\"image\"> </p>\n<p>docker如上图所示，由Client客户端，DOCKER_HOST宿主机，Registry仓库三个部分构成。在客户端部分，用户可以拉取镜像、创建镜像和运行镜像（客户端-服务器的架构。docker client告诉Docker daemon建立、运行、发布你的Docker容器。Docker client和daemon可以运行在一个系统中，或者可以使用Docker client和远程Docker daemon取得联系。docker服务端和docker守护进程之间通过sockets或者REST API交互）。</p>\n<p>运行机制如下描述：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">1.用户在客户端的命令都交给Docker daemon来处理；\n2.如doker run 运行镜像：docker daemon会检查宿主机是否有这个images，若没有则去镜像仓库（Registry）中拉取镜像；\n3.再运行镜像后以容器的形式在宿主机中运行</code></pre>\n<h4 id=\"Docker给DevOps带来的好处\"><a href=\"#Docker给DevOps带来的好处\" class=\"headerlink\" title=\"Docker给DevOps带来的好处\"></a><strong>Docker给DevOps带来的好处</strong></h4><p><strong>更快速的交付和部署</strong>：开发人员可以使用镜像快速的构建标准开发环境；开发完成后，测试和运维人员可以使用开发人员提供的docker镜像快速部署应用，可以避免开发和测试运维人员之间的环境差异导致的部署问题。</p>\n<p><strong>更高校的资源利用</strong>：Docker容器的运行不需要额外的虚拟化管理程序支持，它是内核级的虚拟化，在占用更少资源的情况实现更高的性能。</p>\n<p><strong>更方便的迁移和扩展</strong>：Docker容器几乎可以在任意的平台上运行，包括物理机、虚拟机、公有云、私有云、服务器等。这种兼容使得用户可以在不同的平台之间很方便的完成应用迁移。</p>\n<p><strong>更简单的更新管理</strong>：使用Dockerfile，只需要小小的配置修改，就可以替代以往大量的更新工作，并且所有修改都以增量方式进行分发和更新。</p>\n<h4 id=\"虚拟化与Docker\"><a href=\"#虚拟化与Docker\" class=\"headerlink\" title=\"虚拟化与Docker\"></a><strong>虚拟化与Docker</strong></h4><p>虚拟化的核心是对资源进行抽象，目标往往是为了在同一个机器上运行多个系统或应用，从而提高系统资源的利用率。虚拟化分为很多类型，比如常见的硬件辅助虚拟化（VMware workstation、 KVM等）。<em><strong>Docker所代表的容器虚拟化技术属于操作系统级虚拟化：内核通过创建多个虚拟的操作系统实例（内核和库）来隔离不同的进程</strong></em>。</p>\n<p>传统虚拟化和容器技术结构比较：传统虚拟化技术是在硬件层面实现虚拟化，增加了系统调用链路的环节，有性能损耗；容器虚拟化技术以共享Kernel的方式实现，几乎没有性能损耗。</p>\n<h4 id=\"Docker三大基本概念\"><a href=\"#Docker三大基本概念\" class=\"headerlink\" title=\"Docker三大基本概念\"></a><strong>Docker三大基本概念</strong></h4><h5 id=\"image\"><a href=\"#image\" class=\"headerlink\" title=\"image\"></a><strong>image</strong></h5><p>Docker镜像类似于虚拟机镜像，是一个只读模板，并且包含了文件系统。一个镜像可以只包含一个操作系统环境（比如SUSE镜像），也可以安装了用户程序及其运行环境（比如eBackup镜像）。镜像其实就是一个文件，任何用户程序都可以成为镜像的一部分。</p>\n<p>镜像=操作系统+软件运行环境+用户程序</p>\n<p><img src=\"../img/Docker/2.png\" alt=\"image\"> </p>\n<p>如上图，一个layer就是一个image，多个image又可以打包成一个image。Image类似一个单链表系统，每个image包含一个指向parent image的指针，没有parent image的image是baseimage（image的指针靠sqlite数据库来保存）。</p>\n<p>最上面的一层（不属于image）是可写的,上面的内容依赖于下面的内容，如果要修改下面的内容，先将下面的内容复制到上面再进行修改。</p>\n<p>Image是创建container的基础。</p>\n<h5 id=\"Container\"><a href=\"#Container\" class=\"headerlink\" title=\"Container\"></a><strong>Container</strong></h5><p>容器是从镜像创建的运行实例，可以将其启动、开始。停止、删除，而这些容器都是相互隔离（独立进程），互不可见的。</p>\n<h5 id=\"Repository\"><a href=\"#Repository\" class=\"headerlink\" title=\"Repository\"></a><strong>Repository</strong></h5><p>Repository是image的集合，而Registry是Repository的集合。</p>\n<h4 id=\"Docker在Centos7环境下的安装\"><a href=\"#Docker在Centos7环境下的安装\" class=\"headerlink\" title=\"Docker在Centos7环境下的安装\"></a><strong>Docker在Centos7环境下的安装</strong></h4><hr>\n<p>1.使用root权限登录系统；</p>\n<p>2.更新系统包到最新：</p>\n<p>yum -y update</p>\n<p>3.添加yum仓库</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">cat &gt;&#x2F;etc&#x2F;yum.repos.d&#x2F;docker.repo &lt;&lt;-EOF\n[dockerrepo]\nname&#x3D;Docker Repository\nbaseurl&#x3D;https:&#x2F;&#x2F;yum.dockerproject.org&#x2F;repo&#x2F;main&#x2F;centos&#x2F;7\nenable&#x3D;1\ngpgcheck&#x3D;1\ngpgkey&#x3D;https:&#x2F;&#x2F;yum.dockerproject.org&#x2F;gpg\nEOF&lt;&#x2F;pre&gt;</code></pre>\n<p>如下图：</p>\n<p><img src=\"../img/Docker/3.png\" alt=\"image\"> </p>\n<p>4.安装docker包</p>\n<p>yum install -y docker-engine</p>\n<p>yum install -y docker-selinux</p>\n<p>在使用现成的安装包的时候selinux的安装一定要在docker-engine之前</p>\n<p>yum list installed|grep docker</p>\n<p>5.启动docker</p>\n<p>systemctl start docker.service</p>\n<p>6.验证docker已经正常安装</p>\n<p>docker run hello-world</p>\n<p>7.配置docker开机自启动</p>\n<p>systemctl enable docker.service</p>\n<h4 id=\"Docker的卸载\"><a href=\"#Docker的卸载\" class=\"headerlink\" title=\"Docker的卸载\"></a><strong>Docker的卸载</strong></h4><hr>\n<p>使用yum卸载docker</p>\n<p>1.列出安装的软件包</p>\n<p>yum list installed | grep docker</p>\n<p>2.移除软件包</p>\n<p>yum -y remove docker-engine.x86_64(这命令不会删除镜像，容器，卷组和用户自配置文件)</p>\n<p>3.删除所有镜像，容器和组</p>\n<p>rm -rf /var/lib/docker</p>\n<h4 id=\"Docker指令\"><a href=\"#Docker指令\" class=\"headerlink\" title=\"Docker指令\"></a><strong>Docker指令</strong></h4><p><img src=\"../img/Docker/4.png\" alt=\"image\"></p>\n<p><img src=\"../img/Docker/5.png\" alt=\"image\"> </p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">docker build：创建镜像；\ndocker pull + 镜像名（镜像地址）：获取镜像；\ndocker images：查看本地镜像；\ndocker run + 镜像名 ： 运行镜像 ；\ndocker run -d +镜像名 : 后台运行镜像 ；\ndocker ps : 查看当前运行的容器；\ndocker exec -it + 容器ID：进入容器（如进入Ubuntu）；\ndocker inspect +容器名或容器ID：查看容器所有信息。</code></pre>\n<h4 id=\"Docker网络\"><a href=\"#Docker网络\" class=\"headerlink\" title=\"Docker网络\"></a><strong>Docker网络</strong></h4><hr>\n<p><img src=\"../img/Docker/6.png\" alt=\"image\"> </p>\n<p>如上图所示Docker网络类型有Bridge、Host 和None</p>\n<p>Host模式：容器直接连接到宿主机上，容器内的网络和宿主机的网络一致；</p>\n<p>Bridge模式：以bridge桥段和宿主机相连，启动容器时容器会虚拟出一个网卡，然后连接Bridge再和主机连接。</p>\n<p>开放端口号的形式运行(以下以运行nginx为例)：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">docker run -d -p 8088:80 nginx &#x2F;&#x2F; -d 指后台运行  -p为开启端口号映射 8088为宿主机端口号 80为nginx监听端口号\ndocker run -d -P(大写P) nginx  &#x2F;&#x2F; -P指开放所有端口号，并随即指定端口号作为映射</code></pre>\n<p>开放端口号遇到的问题：</p>\n<p><img src=\"../img/Docker/7.png\" alt=\"image\"> </p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">问题描述：开放端口号失败；\n原因：docker 指定了快速启动方式（百度知道的&#x3D;-&#x3D;）；\n解决办法：重启（restart）Docker后再运行即可。</code></pre>\n\n\n<h4 id=\"Docker制作镜像示例\"><a href=\"#Docker制作镜像示例\" class=\"headerlink\" title=\"Docker制作镜像示例\"></a><strong>Docker制作镜像示例</strong></h4><hr>\n<p>需要用到的操作： Dockerfile的创建，docker build。</p>\n<p>1.创建Dockerfile，示例内容如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">from tomcat &#x2F;&#x2F;注释:运行于tomcat这个容器\nMAINTAINER Jerry_Liang 1097872779@qq.com &#x2F;&#x2F;作者名Jerry_Liang 联系方式1097872779@qq.com\nCOPY 项目名.war  &#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;webapps  &#x2F;&#x2F;将war包拷贝到tomcat容器中</code></pre>\n<p>2.将项目war包放到与Dockerfile的同一目录上；</p>\n<p>3.执行创建镜像命令</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">docker build -t jpress:latest +Dockerfile路径名(如果为当前工作路径则用“.”)\n &#x2F;&#x2F;注释：-t为指定镜像名和后面的latest为镜像标签</code></pre>\n<h4 id=\"volume操作\"><a href=\"#volume操作\" class=\"headerlink\" title=\"volume操作\"></a><strong>volume操作</strong></h4><hr>\n<p>挂载实现：</p>\n<p>第一种方法：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">docker run -p 80:80 -d -v F:\\Docker:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html nginx \n&#x2F;&#x2F;注释：-d 指在以守护进程的模式运行（daemon守护进程） -v 即volume将本地指定的文件夹（此处为本机的F盘下的Docker文件夹）挂载到容器的&#x2F;usr&#x2F;share&#x2F;ngixn&#x2F;html 来实现同步（即主机文件夹有变，容器的文件夹也会发生变化）</code></pre>\n<p>第二种方法：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">1.docker create -v F:\\Docker\\data:&#x2F;var&#x2F;mydata --name data_container ubuntu\n &#x2F;&#x2F;注释 --name指定容器名字  ubuntu指定基础镜像 \n2.docker run -it --volumes-from data_container ubuntu &#x2F;bin&#x2F;bash \n &#x2F;&#x2F;注释 -it交互方式运行，直接进入容器</code></pre>\n<h4 id=\"运行一个好玩的镜像\"><a href=\"#运行一个好玩的镜像\" class=\"headerlink\" title=\"运行一个好玩的镜像\"></a><strong>运行一个好玩的镜像</strong></h4><hr>\n<p>运行结果图：</p>\n<p><img src=\"../img/Docker/8.png\" alt=\"image\"> </p>\n<p>操作：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">首先获取搜索该镜像：docker search whalesay\n然后获取镜像： docker pull docker&#x2F;whalesay\n最后运行：docker run docker&#x2F;whalesay cowsay + 你想说的话（比如我输入的是Docker good）</code></pre>\n<h4 id=\"分享镜像\"><a href=\"#分享镜像\" class=\"headerlink\" title=\"分享镜像\"></a><strong>分享镜像</strong></h4><hr>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">docker login &#x2F;&#x2F;首先是登录，这样才会有权限分享\ndocker push + 本地镜像名</code></pre>\n<h4 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a><strong>参考文章</strong></h4><p>Docker基础：<a href=\"https://blog.csdn.net/weixin_39381833/article/details/80740235\">https://blog.csdn.net/weixin_39381833/article/details/80740235</a></p>\n<p>Docker介绍 ： <a href=\"https://blog.csdn.net/u012299594/article/details/52343910\">https://blog.csdn.net/u012299594/article/details/52343910</a></p>\n<p>视频教程：<a href=\"https://www.imooc.com/video/15727\">https://www.imooc.com/video/15727</a> ； <a href=\"https://www.imooc.com/learn/824\">https://www.imooc.com/learn/824</a></p>\n<p>Linux下的Docker安装教程：<a href=\"https://blog.csdn.net/qq_36892341/article/details/73918672\">https://blog.csdn.net/qq_36892341/article/details/73918672</a></p>\n<p>参考文章：<a href=\"https://www.cnblogs.com/luchuangao/p/7748575.html?tdsourcetag=s_pctim_aiomsg\">https://www.cnblogs.com/luchuangao/p/7748575.html?tdsourcetag=s_pctim_aiomsg</a>#_label0</p>\n","feature":false,"text":"什么是Docker? Docker是基于Go语言实现的云开源项目。Docker的主要目标是“Build，Ship and Run Any App,Anywhere”，也就是通过对应用组件的封装、分发、部署、运行等生命周期的管理，使用户的APP（可以是一个WEB应用或者数据库应用等...","link":"","photos":[],"count_time":{"symbolsCount":"5.1k","symbolsTime":"5 mins."},"categories":[{"name":"Devops","slug":"Devops","count":4,"path":"api/categories/Devops.json"}],"tags":[{"name":"Docker","slug":"Docker","count":1,"path":"api/tags/Docker.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AFDocker\"><span class=\"toc-text\">什么是Docker?</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Docker%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">Docker结构</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Docker%E7%BB%99DevOps%E5%B8%A6%E6%9D%A5%E7%9A%84%E5%A5%BD%E5%A4%84\"><span class=\"toc-text\">Docker给DevOps带来的好处</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%99%9A%E6%8B%9F%E5%8C%96%E4%B8%8EDocker\"><span class=\"toc-text\">虚拟化与Docker</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Docker%E4%B8%89%E5%A4%A7%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">Docker三大基本概念</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#image\"><span class=\"toc-text\">image</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#Container\"><span class=\"toc-text\">Container</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#Repository\"><span class=\"toc-text\">Repository</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Docker%E5%9C%A8Centos7%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E5%AE%89%E8%A3%85\"><span class=\"toc-text\">Docker在Centos7环境下的安装</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Docker%E7%9A%84%E5%8D%B8%E8%BD%BD\"><span class=\"toc-text\">Docker的卸载</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Docker%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">Docker指令</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Docker%E7%BD%91%E7%BB%9C\"><span class=\"toc-text\">Docker网络</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Docker%E5%88%B6%E4%BD%9C%E9%95%9C%E5%83%8F%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">Docker制作镜像示例</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#volume%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">volume操作</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%BF%90%E8%A1%8C%E4%B8%80%E4%B8%AA%E5%A5%BD%E7%8E%A9%E7%9A%84%E9%95%9C%E5%83%8F\"><span class=\"toc-text\">运行一个好玩的镜像</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%88%86%E4%BA%AB%E9%95%9C%E5%83%8F\"><span class=\"toc-text\">分享镜像</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0\"><span class=\"toc-text\">参考文章</span></a></li></ol>","author":{"name":"安安哎呀呀","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"山内有樱名为良，树本无名只待春","socials":{"github":"https://github.com/JeryLiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/243662531"},"jianshu":{"icon":"/svg/jianshu.svg","link":"https://www.jianshu.com/u/f1275d68d75d"}}}},"mapped":true,"prev_post":{"title":"Mybatis","uid":"54e1d69dbe01003cc0c2e45b21bc6b3e","slug":"Mybatis","date":"2018-11-24T07:00:52.000Z","updated":"2021-07-01T07:20:45.933Z","comments":true,"path":"api/articles/Mybatis.json","keywords":null,"cover":"../img/Mybatis/cover.jpeg","text":"一.Mybatis1.Hibernate全表映射，而Mybatis半自动映射且可配置动态SQL 2.Mapper 是一个接口，而没有任何实现类，它的作用是发送SQL，然后返回我们需要的结果，或者执行SQL从而修改数据库的数据。 3.Mybatis别名（typeAliases）不区...","link":"","photos":[],"count_time":{"symbolsCount":"6.1k","symbolsTime":"6 mins."},"categories":[{"name":"Java","slug":"Java","count":7,"path":"api/categories/Java.json"}],"tags":[{"name":"mybatis","slug":"mybatis","count":1,"path":"api/tags/mybatis.json"}],"author":{"name":"安安哎呀呀","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"山内有樱名为良，树本无名只待春","socials":{"github":"https://github.com/JeryLiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/243662531"},"jianshu":{"icon":"/svg/jianshu.svg","link":"https://www.jianshu.com/u/f1275d68d75d"}}}}},"next_post":{"title":"Linux基础","uid":"144f0b4d9b9f80ea377106e9c6a54a45","slug":"Linux基础","date":"2018-07-20T09:49:56.000Z","updated":"2021-07-01T06:36:13.606Z","comments":true,"path":"api/articles/Linux基础.json","keywords":null,"cover":"../img/Linux基础/cover.jpeg","text":"一.基础指令​ file+文件名：查看文件类型 ； ​ cat+文件名：查看文件； ​ less + 文件名：分页查看文件； ​ echo+内容：打印想要输出的内容; ​ echo+内容&gt;文件名：打印内容至指定的文件里; ​ ls +命令（错误的） 2&gt; 文件名： 重...","link":"","photos":[],"count_time":{"symbolsCount":"2.3k","symbolsTime":"2 mins."},"categories":[{"name":"Linux","slug":"Linux","count":2,"path":"api/categories/Linux.json"}],"tags":[{"name":"Linux","slug":"Linux","count":1,"path":"api/tags/Linux.json"}],"author":{"name":"安安哎呀呀","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"山内有樱名为良，树本无名只待春","socials":{"github":"https://github.com/JeryLiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/243662531"},"jianshu":{"icon":"/svg/jianshu.svg","link":"https://www.jianshu.com/u/f1275d68d75d"}}}}}}