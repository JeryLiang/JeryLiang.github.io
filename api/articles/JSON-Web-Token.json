{"title":"JSON Web Token","uid":"6025476afb5f5063e34d3c43d435967b","slug":"JSON-Web-Token","date":"2019-07-23T04:07:07.000Z","updated":"2021-08-13T08:34:34.576Z","comments":true,"path":"api/articles/JSON-Web-Token.json","keywords":null,"cover":"../img/JWT/cover.png","content":"<p>相信大家或多或少都接触过这个场景，那就是我们注册某个一个网站长账号后(账号A)，网站会给我们的注册邮箱发送一封邮件，其中包含了激活链接，一般情况下，这个链接会在几个小时内过期，过期后就无法激活了。同样，你并不能使用这个激活链接来激活你又新注册的一个账号(此处称为账号B)。</p>\n<p>JWT允许我们做到与上面场景同样的效果。在开始如何使用JWT实现类似的无状态验证前，先介绍下JWT的组成。</p>\n<h4 id=\"1-JWT的组成\"><a href=\"#1-JWT的组成\" class=\"headerlink\" title=\"1.JWT的组成\"></a>1.JWT的组成</h4><p>一个JWT实际上就是一个字符串，它由三部分组成，分别是：<code>头部</code>、<code>载荷</code>与<code>签名</code>。</p>\n<h5 id=\"头部-Header\"><a href=\"#头部-Header\" class=\"headerlink\" title=\"头部(Header)\"></a><strong>头部(Header)</strong></h5><p>JWT的头部主要用于描述关于该JWT的最基本的信息，例如其类型以及签名所用算法等。这也可以表示成一个JSON对象。</p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">&#123;\n  &quot;type&quot;: &quot;JWT&quot;,\n  &quot;alg&quot;: &quot;HS256&quot;\n&#125;</code></pre>\n<p>在这里，头部说明了这是一个JWT，并且所用的签名算法为HS256。<br>对JSON对象进行Base64编码后，得到的字符串作为JWT的Header。示例字符串如下</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9</code></pre>\n\n<h5 id=\"载荷-Payload\"><a href=\"#载荷-Payload\" class=\"headerlink\" title=\"载荷(Payload)\"></a><strong>载荷(Payload)</strong></h5><p>载荷就是存放有效信息的地方,它包含声明（要求）。声明有三种类型：</p>\n<p>registered claims：标准中注册的声明。这里有一组预定义的声明，它们不是强制的，但是推荐<br>public claims：公共的声明<br>private claims：私有的声明</p>\n<p>标准中注册的声明 (建议但不强制使用) ：</p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">&#123; \n  &quot;iss&quot;: &quot;Jerry&quot;, \n  &quot;iat&quot;: 1563846005, \n  &quot;exp&quot;: 1563856805, \n  &quot;aud&quot;: &quot;www.example.com&quot;, \n  &quot;sub&quot;: &quot;Jerry@example.com&quot;\n&#125;</code></pre>\n\n<ul>\n<li><code>iss</code>：该JWT的签发者</li>\n<li><code>sub</code>： 该JWT所面向的用户</li>\n<li><code>aud</code>： 接收JWT的一方</li>\n<li><code>exp</code>：JWT的过期时间</li>\n<li><code>iat</code>：JWT的签发时间</li>\n</ul>\n<p>对上面的JSON对象进行Base64编码可以得到一串字符串。这个字符串我们将它称作JWT的Payload。示例：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">eyJpc3MiOiJKb2huIFd1IEpXVCIsImlhdCI6MTQ0MTU5MzUwMiwiZXhwIjoxNDQxNTk0NzIyLCJhdWQiOiJ3d3cuZXhhbXBsZS5jb20iLCJzdWIiOiJqcm9ja2V0QGV4YW1wbGUuY29tIiwiZnJvbV91c2VyIjoiQiIsInRhcmdldF91c2VyIjoiQSJ9</code></pre>\n\n<p>公共的声明 ：<br>公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息.但不建议添加敏感信息，因为该部分在客户端可解密.</p>\n<p>私有的声明 ：<br>私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为base64是对称解密的，意味着该部分信息可以归类为明文信息。<br>对Payload进行Base64加密就得到了JWT第二部分的内容。</p>\n<p>将头部与载荷两个编码后的字符串用句号<code>.</code>连接在一起(头部在前)，就形成了JWT的一部分，如下</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJKb2huIFd1IEpXVCIsImlhdCI6MTQ0MTU5MzUwMiwiZXhwIjoxNDQxNTk0NzIyLCJhdWQiOiJ3d3cuZXhhbXBsZS5jb20iLCJzdWIiOiJqcm9ja2V0QGV4YW1wbGUuY29tIiwiZnJvbV91c2VyIjoiQiIsInRhcmdldF91c2VyIjoiQSJ9</code></pre>\n\n<h5 id=\"签名-Signature\"><a href=\"#签名-Signature\" class=\"headerlink\" title=\"签名(Signature)\"></a><strong>签名(Signature)</strong></h5><p>最后，将上面拼接完的字符串用HS256算法进行加密。在加密的时候，我们还需要提供一个密钥(secret)。加上我们的签名后，使用HS256算法进行加密结果示例如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">rSWamyAYwuHCo7IFAgd1oRpSP7nzL7BF5t7ItqpKViM</code></pre>\n<p>加密后得到的字符串就是我们的签名，我们将这部分与前面的字符串拼接，就得到了完整的JWT：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJKb2huIFd1IEpXVCIsImlhdCI6MTQ0MTU5MzUwMiwiZXhwIjoxNDQxNTk0NzIyLCJhdWQiOiJ3d3cuZXhhbXBsZS5jb20iLCJzdWIiOiJqcm9ja2V0QGV4YW1wbGUuY29tIiwiZnJvbV91c2VyIjoiQiIsInRhcmdldF91c2VyIjoiQSJ9.rSWamyAYwuHCo7IFAgd1oRpSP7nzL7BF5t7ItqpKViM</code></pre>\n<p>参考图：<br><img src=\"../img/JWT/1.png\" alt=\"image.png\"></p>\n<h5 id=\"签名目的\"><a href=\"#签名目的\" class=\"headerlink\" title=\"签名目的\"></a><strong>签名目的</strong></h5><p>最后一步签名的过程，实际上是对头部以及载荷内容进行签名。一般而言，加密算法对于不同的输入产生的输出总是不一样的。对于两个不同的输入，产生同样的输出的概率极其地小（有可能比我成世界首富的概率还小）。所以，我们就把“不一样的输入产生不一样的输出”当做必然事件来看待吧。</p>\n<p>所以，如果有人对头部以及载荷的内容解码之后进行修改，再进行编码的话，那么新的头部和载荷的签名和之前的签名就将是不一样的。而且，如果不知道服务器加密的时候用的密钥的话，得出来的签名也一定会是不一样的。<br>服务器应用在接受到JWT后，会首先对头部和载荷的内容用同一算法再次签名。那么服务器应用是怎么知道我们用的是哪一种算法呢？别忘了，我们在JWT的头部中已经用<code>alg</code>字段指明了我们的加密算法了。</p>\n<p>如果服务器应用对头部和载荷再次以同样方法签名之后发现，自己计算出来的签名和接受到的签名不一样，那么就说明这个Token的内容被别人动过的，我们应该拒绝这个Token，返回一个HTTP 401 Unauthorized响应。</p>\n<h4 id=\"2-回顾文章开头的场景\"><a href=\"#2-回顾文章开头的场景\" class=\"headerlink\" title=\"2. 回顾文章开头的场景\"></a>2. 回顾文章开头的场景</h4><p>在了解了JWT的生成过程后，你猜到了开头场景是如何实现的了嘛？<br>没错，其中：</p>\n<ul>\n<li>第一个有效时间是服务器在签发JWT时设置的<code>exp</code>过期时间；</li>\n<li>第二个的不能用于激活其他账号原因是我们可以在载荷中设置该JWT所面向的用户。</li>\n</ul>\n<h4 id=\"3-JWT使用场景\"><a href=\"#3-JWT使用场景\" class=\"headerlink\" title=\"3. JWT使用场景\"></a>3. JWT使用场景</h4><ul>\n<li><p>一次性验证：如文中开头所说的场景，这种场景就和JWT的特性非常的贴近，JWT中的<code>Payload</code>固定的参数：<code>iss</code>签发者和<code>exp</code>过期时间正是为其准备的；</p>\n</li>\n<li><p>RESTful api的无状态认证。</p>\n</li>\n</ul>\n<h4 id=\"4-Token对比Session验证机制\"><a href=\"#4-Token对比Session验证机制\" class=\"headerlink\" title=\"4. Token对比Session验证机制\"></a>4. Token对比Session验证机制</h4><p>#####4.1 <strong>基于session的验证机制</strong><br>http协议本身是一种无状态的协议，而这就意味着如果用户向我们的应用提供了用户名和密码来进行用户认证，那么下一次请求时，用户还要再一次进行用户认证才行，因为根据http协议，我们并不能知道是哪个用户发出的请求，所以为了让我们的应用能识别是哪个用户发出的请求，我们只能在服务器存储一份用户登录的信息，这份登录信息会在响应时传递给浏览器，告诉其保存为cookie,以便下次请求时发送给我们的应用，这样我们的应用就能识别请求来自哪个用户了,这就是传统的基于session认证。<br>但是这种基于session的认证使应用本身很难得到扩展，随着不同客户端用户的增加，独立的服务器已无法承载更多的用户，而这时候基于session认证应用的问题就会暴露出来：</p>\n<ul>\n<li>Session: 每个用户经过我们的应用认证之后，我们的应用都要在服务端做一次记录，以方便用户下次请求的鉴别，通常而言session都是保存在内存中，而随着认证用户的增多，服务端的开销会明显增大；</li>\n<li>扩展性: 用户认证之后，服务端做认证记录，如果认证的记录被保存在内存中的话，这意味着用户下次请求还必须要请求在这台服务器上,这样才能拿到授权的资源，这样在分布式的应用上，相应的限制了负载均衡器的能力。这也意味着限制了应用的扩展能力；</li>\n<li>CSRF: 因为是基于cookie来进行用户识别的, cookie如果被截获，用户就会很容易受到跨站请求伪造的攻击；</li>\n</ul>\n<p>针对扩展性，如果我们要实现分布式部署，需要我们做好集群间session的共享，这样我们才能很好的扩展我们的应用。</p>\n<p>#####4.2 <strong>基于Token的验证机制</strong><br>Token机制相对于传统的session认证(即Cookie机制)，有以下的好处：</p>\n<ul>\n<li>支持跨域访问：Cookie是不允许垮域访问的，这一点对Token机制是不存在的，前提是传输的用户认证信息通过HTTP头传输；</li>\n<li>无状态：Token不需要在服务端额外存储，而session需要在服务端存储以便认证；</li>\n<li>去耦：不需要绑定到一个特定的身份验证方案；</li>\n<li>更实用于移动应用：当你的客户端是一个原生平台（iOS, Android，Windows 8等）时，Cookie是不被支持的（你需要通过Cookie容器进行处理），这时采用Token认证机制就会简单得多；</li>\n<li>CSRF：因为不再依赖于Cookie，所以不再需要考虑对CSRF(跨站请求伪造)的防范；</li>\n<li>性能：一次网络往返时间（通过数据库查询session信息）总比做一次HMACSHA256计算 的Token验证和解析要费时得多。</li>\n</ul>\n<p>我们也知道，很难有一种技术是万能的，无懈可击的，基于Token的验证机制同样有它的缺点：</p>\n<ul>\n<li>注销：传统的 session+cookie 方案用户点击注销，服务端清空 session 即可，因为状态保存在服务端。但 JWT的方案就比较难办了，因为 JWT是无状态的，服务端通过计算来校验有效性。没有存储起来，所以即使客户端删除了 JWT，但是该 jwt 还是在有效期内，只不过处于一个游离状态。分析下痛点：注销变得复杂的原因在于 JWT的无状态；</li>\n<li>续签问题：JWT本身的Payload之中的<code>exp</code>过期参数，来代表JWT的时效性，而JWT想延期这个<code>exp</code>就有点身不由己了，因为payload是参与签名的，一旦过期时间被修改，整个JWT串就变了，所以续签问题也是JWT的一个缺点。</li>\n</ul>\n<p>针对注销，我们可以清空或者修改服务端的用户对应的secret(这种情况下，我们的每个用户secret都是不一样的，即和用户关联,而不是使用统一的secret)，这样用户在注销后，JWT本身不变，但是由于secret不存在或者改变，则无法完成校验。(仅做参考，我们可以按照我们实际需求设计)</p>\n<p>针对于续签问题，我们可以考虑这一种方案：<br>服务端JWT过期时间依旧按常规设置，签发时同时存入redis，在redis中的过期时间为服务端签发的两倍(依个人而设置，大于服务端存储的就好)。验证的时候正常进行：</p>\n<ul>\n<li>当发现JWT过期的时候，去redis中查找该JWT是否存在或是否已过期，若无过期，则签发新的JWT，并更新redis中该JWT的过期时间；</li>\n<li>当发现JWT过期，同时redis中的也过期了，那么跳转到登录页面，让用户重新登录。</li>\n</ul>\n<p>续签可以很好的解决这样的问题：那就是如果用户非常活跃，用户在使用超过我们的过期时间还在使用系统，那么他又得重新登录。用户体验性会很差，所以需要我们增加续签的功能来提高用户体验。</p>\n<h4 id=\"5-Springboot中的JWT实现\"><a href=\"#5-Springboot中的JWT实现\" class=\"headerlink\" title=\"5. Springboot中的JWT实现\"></a>5. Springboot中的JWT实现</h4><h5 id=\"5-1-引入依赖\"><a href=\"#5-1-引入依赖\" class=\"headerlink\" title=\"5.1 引入依赖\"></a>5.1 引入依赖</h5><p>在<code>pom.xml</code>中加入我们的依赖</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&lt;dependency&gt;\n           &lt;groupId&gt;io.jsonwebtoken&lt;&#x2F;groupId&gt;\n           &lt;artifactId&gt;jjwt-api&lt;&#x2F;artifactId&gt;\n           &lt;version&gt;0.10.7&lt;&#x2F;version&gt;\n       &lt;&#x2F;dependency&gt;\n       &lt;dependency&gt;\n           &lt;groupId&gt;io.jsonwebtoken&lt;&#x2F;groupId&gt;\n           &lt;artifactId&gt;jjwt-impl&lt;&#x2F;artifactId&gt;\n           &lt;version&gt;0.10.7&lt;&#x2F;version&gt;\n           &lt;scope&gt;runtime&lt;&#x2F;scope&gt;\n       &lt;&#x2F;dependency&gt;\n       &lt;dependency&gt;\n           &lt;groupId&gt;io.jsonwebtoken&lt;&#x2F;groupId&gt;\n           &lt;artifactId&gt;jjwt-jackson&lt;&#x2F;artifactId&gt;\n           &lt;version&gt;0.10.7&lt;&#x2F;version&gt;\n           &lt;scope&gt;runtime&lt;&#x2F;scope&gt;\n       &lt;&#x2F;dependency&gt;\n       &lt;!-- Uncomment this next dependency if you want to use RSASSA-PSS (PS256, PS384, PS512) algorithms:  --&gt;\n       &lt;dependency&gt;\n           &lt;groupId&gt;org.bouncycastle&lt;&#x2F;groupId&gt;\n           &lt;artifactId&gt;bcprov-jdk15on&lt;&#x2F;artifactId&gt;\n           &lt;version&gt;1.60&lt;&#x2F;version&gt;\n           &lt;scope&gt;runtime&lt;&#x2F;scope&gt;\n       &lt;&#x2F;dependency&gt;</code></pre>\n<p>编写我们的<code>TokenUtil.class</code> 以下为示例代码：</p>\n<ul>\n<li>其中<code>secret</code>需要修改成我们自己的；</li>\n<li>生成Token的<code>createJWT</code>函数需要的入参我们可以按需修改；</li>\n<li>同时设置JWT claims时也可以根据我们需求做相应的修改；</li>\n<li><code>parseJWT</code>函数是我们解析Token并认证的过程。<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">import javax.crypto.spec.SecretKeySpec;\nimport javax.xml.bind.DatatypeConverter;\nimport java.security.Key;\n\nimport io.jsonwebtoken.*;\n\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport org.slf4j.*;\n\n\n&#x2F;**\n * @Author: JerryLiang\n * @Date: 2019&#x2F;7&#x2F;15 10:53\n **&#x2F;\npublic class TokenUtil &#123;\n\n    private final static Logger logger &#x3D; LoggerFactory.getLogger(TokenUtil.class);\n\n    private final static String myApiKeySecret &#x3D; &quot;这里写入你的Secret&quot;;\n\n\n    &#x2F;**\n     * 创建JSON WEB TOKEN\n     * @param id\n     * @param userName\n     * @param userPower\n     * @param ttlMillis\n     * @return\n     *&#x2F;\n    public static String createJWT(String id, String userName, String userPower, long ttlMillis)&#123;\n\n        &#x2F;&#x2F;设置签名算法\n        SignatureAlgorithm signatureAlgorithm &#x3D; SignatureAlgorithm.HS256;\n        long nowMillis &#x3D; System.currentTimeMillis();\n        Date now &#x3D; new Date(nowMillis);\n        &#x2F;&#x2F;设置密钥\n        byte[] apiKeySecretBytes &#x3D; DatatypeConverter.parseBase64Binary(myApiKeySecret);\n        Key signingKey &#x3D; new SecretKeySpec(apiKeySecretBytes, signatureAlgorithm.getJcaName());\n        &#x2F;&#x2F;设置JWT claims\n        JwtBuilder builder &#x3D; Jwts.builder().setHeaderParam(&quot;typ&quot;, &quot;JWT&quot;)\n                .setId(id)\n                .setIssuedAt(now)\n                .setAudience(&quot;iot&quot;)\n                .setIssuer(&quot;Jerry&quot;)  &#x2F;&#x2F;设置发行者，自定义\n                .claim(&quot;userName&quot;, userName)\n                .claim(&quot;userPower&quot;, userPower)\n                .signWith(signatureAlgorithm, signingKey);\n\n        &#x2F;&#x2F;设置超时时间\n        if (ttlMillis &gt;&#x3D; 0) &#123;\n            long expMillis &#x3D; nowMillis + ttlMillis;\n            Date exp &#x3D; new Date(expMillis);\n            builder.setExpiration(exp);\n        &#125;\n\n        &#x2F;&#x2F;生成JWT\n        return builder.compact();\n\n    &#125;\n\n    &#x2F;**\n     * 解析JWT，并验证用户权限\n     * @param jwt\n     *&#x2F;\n    public static Boolean parseJWT(String jwt) throws ParseException &#123;\n\n        if (jwt &#x3D;&#x3D; null) &#123;\n            logger.error(&quot;----------Token不能为空------------&quot;);\n            return false;\n        &#125;\n        try &#123;\n            Claims claims &#x3D; Jwts.parser()\n                    .setSigningKey(DatatypeConverter.parseBase64Binary(myApiKeySecret))\n                    .parseClaimsJws(jwt).getBody();\n\n            &#x2F;&#x2F;将超时时间格式化为时间戳time\n            SimpleDateFormat sdf &#x3D; new SimpleDateFormat(&quot;yyyy&#x2F;MM&#x2F;dd HH:mm:ss&quot;);\n            String timeFormat &#x3D; sdf.format(claims.getExpiration());\n\n            Date date &#x3D; sdf.parse(timeFormat);\n            long time &#x3D; date.getTime();\n            long currentTime &#x3D; System.currentTimeMillis();\n\n\n            return (&quot;Jerry&quot;).equals(claims.getIssuer()) &amp;&amp;\n                    (&quot;iot&quot;).equals(claims.getAudience()) &amp;&amp;\n                    (time &gt; currentTime) &amp;&amp;\n                    claims.get(&quot;userName&quot;) !&#x3D; null;\n\n        &#125;catch (Exception e)&#123;\n            e.printStackTrace();\n            logger.error(&quot;----------Token格式有误------------&quot;);\n            return false;\n        &#125;\n    &#125;\n\n    &#x2F;**\n     * 获取jwt中的userName\n     * @param jwt\n     * @return\n     *&#x2F;\n   public static String getUserName(String jwt)&#123;\n\n       Claims claims &#x3D; Jwts.parser()\n               .setSigningKey(DatatypeConverter.parseBase64Binary(myApiKeySecret))\n               .parseClaimsJws(jwt).getBody();\n\n       return claims.get(&quot;userName&quot;).toString();\n   &#125;\n\n&#125;\n</code></pre>\n我们在需要验证的接口中调用TokenUtil中的方法就可以了。示例如下<pre class=\"line-numbers language-none\"><code class=\"language-none\">if(TokenUtil.parseJWT(jwt))&#123;\n      &#x2F;&#x2F;此处为验证通过执行的代码\n&#125;else&#123;\n      &#x2F;&#x2F;此处为验证不通过执行的代码\n&#125;</code></pre>\n至此，基于JWT的验证已经完成了，但是上面的代码中我并没有加入解决续签问题的解决方案的示例代码，可以参考我的另一篇关于<a href=\"https://www.jianshu.com/p/cf9b28a6696d\">springboot整合redis的文章</a>，我们在<code>createJWT</code>函数中，生成完后将JWT存入redis即可，同时，在使用<code>parseJWT</code>解析认证后，若失败，则查询redis是否存在该JWT，若存在则重新调用createJWT签发新的JWT，再存入redis中即可。</li>\n</ul>\n<p>注意：大家或许可能会想，这里借助redis存储JWT，是不是性质已经和session差不多了呀？其实不然，此处存储的目的是解决续签问题，而并没有实际的验证比对，所以并不是一样的哈！</p>\n<h4 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h4><p><a href=\"http://blog.didispace.com/learn-how-to-use-jwt-xjf/\">http://blog.didispace.com/learn-how-to-use-jwt-xjf/</a></p>\n<p><a href=\"https://www.cnblogs.com/hongdiandian/p/9294970.html\">https://www.cnblogs.com/hongdiandian/p/9294970.html</a></p>\n<p><a href=\"https://blog.csdn.net/qq_38306688/article/details/88643545\">https://blog.csdn.net/qq_38306688/article/details/88643545</a></p>\n","feature":true,"text":"相信大家或多或少都接触过这个场景，那就是我们注册某个一个网站长账号后(账号A)，网站会给我们的注册邮箱发送一封邮件，其中包含了激活链接，一般情况下，这个链接会在几个小时内过期，过期后就无法激活了。同样，你并不能使用这个激活链接来激活你又新注册的一个账号(此处称为账号B)。 JWT...","link":"","photos":[],"count_time":{"symbolsCount":"10k","symbolsTime":"9 mins."},"categories":[{"name":"Java","slug":"Java","count":8,"path":"api/categories/Java.json"}],"tags":[{"name":"jwt","slug":"jwt","count":1,"path":"api/tags/jwt.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-JWT%E7%9A%84%E7%BB%84%E6%88%90\"><span class=\"toc-text\">1.JWT的组成</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%A4%B4%E9%83%A8-Header\"><span class=\"toc-text\">头部(Header)</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E8%BD%BD%E8%8D%B7-Payload\"><span class=\"toc-text\">载荷(Payload)</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E7%AD%BE%E5%90%8D-Signature\"><span class=\"toc-text\">签名(Signature)</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E7%AD%BE%E5%90%8D%E7%9B%AE%E7%9A%84\"><span class=\"toc-text\">签名目的</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E5%9B%9E%E9%A1%BE%E6%96%87%E7%AB%A0%E5%BC%80%E5%A4%B4%E7%9A%84%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">2. 回顾文章开头的场景</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-JWT%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">3. JWT使用场景</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-Token%E5%AF%B9%E6%AF%94Session%E9%AA%8C%E8%AF%81%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">4. Token对比Session验证机制</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-Springboot%E4%B8%AD%E7%9A%84JWT%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">5. Springboot中的JWT实现</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#5-1-%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96\"><span class=\"toc-text\">5.1 引入依赖</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83\"><span class=\"toc-text\">参考</span></a></li></ol>","author":{"name":"安安哎呀呀","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"山内有樱名为良，树本无名只待春","socials":{"github":"https://github.com/JeryLiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/243662531"},"jianshu":{"icon":"/svg/jianshu.svg","link":"https://www.jianshu.com/u/f1275d68d75d"}}}},"mapped":true,"prev_post":{"title":"如何设计风格良好的Restful API","uid":"4ad927e9758be2d736a1a9cb9de5ab88","slug":"如何设计风格良好的Restful-API","date":"2019-12-04T14:56:30.000Z","updated":"2021-08-13T08:40:29.430Z","comments":true,"path":"api/articles/如何设计风格良好的Restful-API.json","keywords":null,"cover":"../img/RESTful/cover.png","text":"最近朋友们都在讨论项目Api规范的问题，大家对Restful风格的Api都或多或少有所了解，但是没人能明确说明Restful到底是什么情况下才能认为是Restful，比如说下面的这类代码算Restful 嘛？ @RequestMapping(value &#x3D; &quot;...","link":"","photos":[],"count_time":{"symbolsCount":"5.7k","symbolsTime":"5 mins."},"categories":[{"name":"RestfulApi","slug":"RestfulApi","count":1,"path":"api/categories/RestfulApi.json"}],"tags":[{"name":"RestfulApi","slug":"RestfulApi","count":1,"path":"api/tags/RestfulApi.json"}],"author":{"name":"安安哎呀呀","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"山内有樱名为良，树本无名只待春","socials":{"github":"https://github.com/JeryLiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/243662531"},"jianshu":{"icon":"/svg/jianshu.svg","link":"https://www.jianshu.com/u/f1275d68d75d"}}}},"feature":true},"next_post":{"title":"Centos7中的Anaconda安装并开启远程访问jupyter","uid":"72eedad54c92985af6f56cde2713a88f","slug":"Centos7中的Anaconda安装并开启远程访问jupyter","date":"2019-07-14T11:51:32.000Z","updated":"2021-07-28T11:58:49.048Z","comments":true,"path":"api/articles/Centos7中的Anaconda安装并开启远程访问jupyter.json","keywords":null,"cover":"../img/远程访问jupyter/cover.jpeg","text":"由于最近在做深度学习相关的学习，需要使用GPU跑代码，但是发现每次需要跑代码的时候都要把代码考上去，而且不怎么方便调试，为此使用Anaconda的jupyter来写代码，可以通过远程服务器上的jupyter来实现本地实时调代码，为此特意查找了相关的远程jupyter资料，特此整理...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"深度学习","slug":"深度学习","count":2,"path":"api/categories/深度学习.json"}],"tags":[{"name":"环境配置","slug":"环境配置","count":2,"path":"api/tags/环境配置.json"}],"author":{"name":"安安哎呀呀","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"山内有樱名为良，树本无名只待春","socials":{"github":"https://github.com/JeryLiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/243662531"},"jianshu":{"icon":"/svg/jianshu.svg","link":"https://www.jianshu.com/u/f1275d68d75d"}}}}}}