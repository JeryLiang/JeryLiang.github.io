{"title":"消息队列(二)——技术选型","uid":"2772ec5587279a800698d9e5d832844d","slug":"消息队列-二-——技术选型","date":"2019-12-09T12:51:17.000Z","updated":"2021-08-16T12:50:56.831Z","comments":true,"path":"api/articles/消息队列-二-——技术选型.json","keywords":null,"cover":"../img/MQ/cover2.png","content":"<p>在了解了消息队列的常用场景后，我们考虑接下来的选型问题。如今使用较多的消息队列有ActiveMQ、RabbitMQ、ZeroMQ、Kafka、MetaMQ、RocketMQ等，以及部分数据库如Redis也可以实现消息队列功能。我们该选择哪一种来引入我们的项目中呢？那么接下来，主要分析关于各大主流消息队列的特性与优缺点。</p>\n<h4 id=\"1-RabbitMQ\"><a href=\"#1-RabbitMQ\" class=\"headerlink\" title=\"1. RabbitMQ\"></a>1. RabbitMQ</h4><hr>\n<h5 id=\"1-1-概述\"><a href=\"#1-1-概述\" class=\"headerlink\" title=\"1.1 概述\"></a>1.1 概述</h5><hr>\n<p>RabbitMQ是使用Erlang编写的一个开源的消息队列，本身支持很多的协议：AMQP，XMPP, SMTP, STOMP，也正因如此，它非常重量级，更适合于企业级的开发。同时实现了Broker构架，这意味着消息在发送给客户端时先在中心队列排队。对路由，负载均衡或者数据持久化都有很好的支持。</p>\n<h5 id=\"1-2-特性\"><a href=\"#1-2-特性\" class=\"headerlink\" title=\"1.2 特性\"></a>1.2 特性</h5><hr>\n<ul>\n<li><code>可靠性</code>：提供了多种技术可以让我们在性能和可靠性之间进行权衡。这些技术包括持久性机制、投递确认、发布者证实和高可用性机制；</li>\n<li><code>灵活的路由</code>：消息在到达队列前是通过交换机进行路由的。RabbitMQ为典型的路由逻辑提供了多种内置交换机类型。如果你有更复杂的路由需求，可以将这些交换机组合起来使用，你甚至可以实现自己的交换机类型，并且当做RabbitMQ的插件来使用；</li>\n<li><code>消息集群</code>：在相同局域网中的多个RabbitMQ服务器可以聚合在一起，作为一个独立的逻辑代理来使用；</li>\n<li><code>队列高可用</code>：队列可以在集群中的机器上进行镜像，以确保在硬件问题下还保证消息安全；</li>\n<li><code>支持多种协议</code>：支持多种消息队列协议；</li>\n<li><code>支持多种语言</code>：用Erlang语言编写，支持只要是你能想到的所有编程语言；</li>\n<li><code>管理界面</code>：RabbitMQ有一个易用的用户界面，使得用户可以监控和管理消息Broker的许多方面；</li>\n<li><code>跟踪机制</code>：如果消息异常，RabbitMQ 提供消息跟踪机制，使用者可以找出发生了什么；</li>\n<li><code>插件机制</code>：提供了许多插件，来从多方面进行扩展，也可以编写自己的插件。</li>\n</ul>\n<h5 id=\"1-3-优缺点\"><a href=\"#1-3-优缺点\" class=\"headerlink\" title=\"1.3 优缺点\"></a>1.3 优缺点</h5><p><code>优点</code>：</p>\n<ul>\n<li>由于Erlang语言的特性，消息队列性能较好，支持高并发；</li>\n<li>健壮、稳定、易用、跨平台、支持多种语言、文档齐全；</li>\n<li>有消息确认机制和持久机制，可靠性高；</li>\n<li>高度可定制的路由；</li>\n<li>管理界面较丰富，在互联网公司也有较大规模的应用，社区活跃度搞。</li>\n</ul>\n<p><code>缺点</code>：</p>\n<ul>\n<li>尽管结合Erlang语言本身的并发优势，性能较好，但是不利于做二次开发和维护；</li>\n<li>实现了代理架构，意味着消息在发送到客户端之前可以在中央节点上排队。此特性使得RabbitMQ易于使用和部署，但是使得其运行速度较慢，因为中央节点 增加了延迟，消息封装后也比较大；需要学习比较复杂的接口和协议，学习和维护成本较高。</li>\n</ul>\n<h4 id=\"2-Redis\"><a href=\"#2-Redis\" class=\"headerlink\" title=\"2.Redis\"></a>2.Redis</h4><hr>\n<p>Redis是一个基于Key-Value对的NoSQL数据库，开发维护很活跃。虽然它是一个Key-Value数据库存储系统，但它本身支持MQ功能，所以完全可以当做一个轻量级的队列服务来使用。对于RabbitMQ和Redis的入队和出队操作，各执行100万次，每10万次记录一次执行时间。测试数据分为128Bytes、512Bytes、1K和10K四个不同大小的数据。实验表明：入队时，当数据比较小时Redis的性能要高于RabbitMQ，而如果数据大小超过了10K，Redis则慢的无法忍受；出队时，无论数据大小，Redis都表现出非常好的性能，而RabbitMQ的出队性能则远低于Redis。</p>\n<h4 id=\"3-ZeroMQ\"><a href=\"#3-ZeroMQ\" class=\"headerlink\" title=\"3.ZeroMQ\"></a>3.ZeroMQ</h4><hr>\n<h5 id=\"3-1-概述\"><a href=\"#3-1-概述\" class=\"headerlink\" title=\"3.1 概述\"></a>3.1 概述</h5><hr>\n<p>ZeroMQ号称最快的消息队列系统，基于c语言开发的。它跟其它MQ有着本质的区别，它根本就不是一个消息队列服务器，更像是一组底层网络通讯库，对原有的Socket API加上一层封装，使用时只需要引入相应jar包即可。</p>\n<h5 id=\"3-2-特性\"><a href=\"#3-2-特性\" class=\"headerlink\" title=\"3.2 特性\"></a>3.2 特性</h5><hr>\n<ul>\n<li><p>嵌入式消息组件；</p>\n</li>\n<li><p>仅提供非持久性的队列，如果宕机，数据将会丢失。如需持久化需要自己进行扩展；</p>\n</li>\n<li><p>高吞吐量：<br>下图是挪用别人的在Windows Vista中测试的数据，展示了每秒钟的发送和接收的消息数，整个过程产生一百万条1k的数据。<br><img src=\"../img/MQ/2-1.png\" alt=\"吞吐量对比\"></p>\n</li>\n<li><p>多核下的线程绑定，即ZeroMQ会将工作线程绑定到每一个核，免除线程上下文切换带来的开销。</p>\n</li>\n</ul>\n<h5 id=\"3-3-应用场景\"><a href=\"#3-3-应用场景\" class=\"headerlink\" title=\"3.3 应用场景\"></a>3.3 应用场景</h5><hr>\n<p>虽然ZeroMQ的吞吐量相比于其他MQ的吞吐量大了不是一个级别的，但由于它的不可靠传输性质（不保证数据不丢失），我们往往不会把它用在需要保证数据不丢失的场景中（除非我们自己扩展它保证数据的可靠性，但很明显，成本是相对较高的）。</p>\n<h4 id=\"4-ActiveMQ\"><a href=\"#4-ActiveMQ\" class=\"headerlink\" title=\"4.ActiveMQ\"></a>4.ActiveMQ</h4><hr>\n<h5 id=\"4-1概述\"><a href=\"#4-1概述\" class=\"headerlink\" title=\"4.1概述\"></a>4.1概述</h5><hr>\n<p>ActiveMQ是Apache所提供的一个开源的消息系统，完全采用Java来实现，因此，它能很好地支持J2EE提出的JMS（Java Message Service,即Java消息服务）规范。JMS是一组Java应用程序接口，它提供消息的创建、发送、读取等一系列服务。JMS提供了一组公共应用程序接口和响应的语法，类似于Java数据库的统一访问接口JDBC,它是一种与厂商无关的API，使得Java程序能够与不同厂商的消息组件很好地进行通信。</p>\n<h5 id=\"4-2-特性\"><a href=\"#4-2-特性\" class=\"headerlink\" title=\"4.2 特性\"></a>4.2 特性</h5><hr>\n<ul>\n<li><code>服从JMS规范</code>：JMS 规范提供了良好的标准和保证，包括：同步 或 异步 的消息分发，一次和仅一次的消息分发，消息接收和订阅等等。遵从JMS规范的好处在于，不论使用什么JMS实现提供者，这些基础特性都是可用的；</li>\n<li><code>连接灵活性</code>：ActiveMQ提供了广泛的连接协议，支持的协议有：HTTP/S，IP多播，SSL，TCP，UDP等等。对众多协议的支持让ActiveMQ拥有了很好的灵活性；</li>\n<li><code>支持的协议种类多</code>：OpenWire、STOMP、REST、XMPP、AMQP；</li>\n<li><code>持久化插件和安全插件</code>：ActiveMQ提供了多种持久化选择。而且，ActiveMQ的安全性也可以完全依据用户需求进行自定义鉴权和授权；</li>\n<li><code>支持的客户端语言种类多</code>：除了Java之外，还有：C/C++，.NET，Perl，PHP，Python，Ruby；</li>\n<li><code>代理集群</code>：多个ActiveMQ代理可以组成一个集群来提供服务；</li>\n<li><code>异常简单的管理</code>：ActiveMQ是以开发者思维被设计的。所以，它并不需要专门的管理员，因为它提供了简单又使用的管理特性。有很多中方法可以监控ActiveMQ不同层面的数据，包括使用在JConsole或者ActiveMQ的WebConsole中使用JMX。通过处理JMX的告警消息，通过使用命令行脚本，甚至可以通过监控各种类型的日志。</li>\n</ul>\n<h5 id=\"4-3-优缺点\"><a href=\"#4-3-优缺点\" class=\"headerlink\" title=\"4.3 优缺点\"></a>4.3 优缺点</h5><hr>\n<p><code>优点</code>：</p>\n<ul>\n<li><code> 跨平台</code>：JAVA编写与平台无关，ActiveMQ几乎可以运行在任何的JVM上；</li>\n<li> <code>可以用JDBC</code>：可以将数据持久化到数据库。虽然使用JDBC会降低ActiveMQ的性能，但是数据库一直都是开发人员最熟悉的存储介质；</li>\n<li> <code>支持JMS规范</code>：支持JMS规范提供的统一接口;</li>\n<li>支持自动重连和错误重试机制；</li>\n<li><code>有安全机制</code>：支持基于shiro，jaas等多种安全配置机制，可以对Queue/Topic进行认证和授权；</li>\n<li><code>监控完善</code>：拥有完善的监控，包括WebConsole，JMX，Shell命令行，Jolokia的RESTful API；</li>\n<li><code>界面友善</code>：提供的WebConsole可以满足大部分情况，还有很多第三方的组件可以使用，比如hawtio；</li>\n</ul>\n<p><code>缺点</code>：</p>\n<ul>\n<li>社区活跃度不及RabbitMQ高；</li>\n<li>根据其他用户反馈，会出莫名其妙的问题，会丢失消息；</li>\n<li>目前重心放到activemq6.0产品Apollo，对5.x的维护较少；</li>\n<li>不适合用于上千个队列的应用场景</li>\n</ul>\n<h4 id=\"5-RocketMQ\"><a href=\"#5-RocketMQ\" class=\"headerlink\" title=\"5.RocketMQ\"></a>5.RocketMQ</h4><hr>\n<h5 id=\"5-1-概述\"><a href=\"#5-1-概述\" class=\"headerlink\" title=\"5.1 概述\"></a>5.1 概述</h5><hr>\n<p>RocketMQ出自阿里的开源产品，用Java语言实现，在设计时参考了Kafka，并做出了自己的一些改进，消息可靠性上比Kafka更好。RocketMQ在阿里内部被广泛应用在订单，交易，充值，流计算，消息推送，日志流式处理，binglog分发等场景。</p>\n<h5 id=\"5-2-主要特性\"><a href=\"#5-2-主要特性\" class=\"headerlink\" title=\"5.2 主要特性\"></a>5.2 主要特性</h5><hr>\n<ul>\n<li>基于 队列模型：具有高性能、高可靠、高实时、分布式等特点；</li>\n<li>Producer、Consumer、队列都支持分布式；</li>\n<li>Producer向一些队列轮流发送消息，队列集合称为Topic。Consumer如果做广播消费，则一个Consumer实例消费这个Topic对应的所有队列；如果做集群消费，则多个Consumer 实例平均消费这个Topic对应的队列集合；</li>\n<li>能够保证严格的消息顺序；</li>\n<li>提供丰富的消息拉取模式；</li>\n<li>高效的订阅者水平扩展能力；</li>\n<li>实时的消息订阅机制；</li>\n<li>亿级消息堆积 能力；</li>\n<li>较少的外部依赖。</li>\n</ul>\n<h5 id=\"5-3-优缺点\"><a href=\"#5-3-优缺点\" class=\"headerlink\" title=\"5.3 优缺点\"></a>5.3 优缺点</h5><hr>\n<p><code>优点</code>：</p>\n<ul>\n<li>单机支持1万以上持久化队列；</li>\n<li>RocketMQ的所有消息都是持久化的，先写入系统PAGECACHE，然后刷盘，可以保证内存与磁盘都有一份数据，而访问时，直接从内存读取。</li>\n<li>模型简单，接口易用（JMS的接口很多场合并不太实用）；</li>\n<li>性能非常好，可以允许大量堆积消息在Broker中；</li>\n<li>支持多种消费模式，包括集群消费、广播消费等；</li>\n<li>各个环节分布式扩展设计，支持主从和高可用；</li>\n<li>开发度较活跃，版本更新很快。</li>\n</ul>\n<p><code>缺点</code>：</p>\n<ul>\n<li>支持的 客户端语言不多，目前是Java及C++，其中C++还不成熟；</li>\n<li>RocketMQ社区关注度及成熟度也不及前两者；</li>\n<li>没有Web管理界面，提供了一个 CLI (命令行界面) 管理工具带来查询、管理和诊断各种问题；</li>\n<li>没有在MQ核心里实现JMS等接口；</li>\n</ul>\n<h4 id=\"6-Kafka-jafka\"><a href=\"#6-Kafka-jafka\" class=\"headerlink\" title=\"6.Kafka/jafka\"></a>6.Kafka/jafka</h4><hr>\n<h5 id=\"6-1-概述\"><a href=\"#6-1-概述\" class=\"headerlink\" title=\"6.1 概述\"></a>6.1 概述</h5><hr>\n<p>Kafka是Apache下的一个子项目，是一个高性能跨语言分布式发布/订阅消息队列系统，而Jafka是在Kafka之上孵化而来的，即Kafka的一个升级版。具有以下特性：快速持久化，可以在O(1)的系统开销下进行消息持久化；高吞吐，在一台普通的服务器上既可以达到10W/s的吞吐速率；完全的分布式系统，Broker、Producer、Consumer都原生自动支持分布式，自动实现负载均衡；支持Hadoop数据并行加载，对于像Hadoop的一样的日志数据和离线分析系统，但又要求实时处理的限制，这是一个可行的解决方案。Kafka通过Hadoop的并行加载机制统一了在线和离线的消息处理。Apache Kafka相对于ActiveMQ是一个非常轻量级的消息系统，除了性能非常好之外，还是一个工作良好的分布式系统。</p>\n<h5 id=\"6-2-主要特性\"><a href=\"#6-2-主要特性\" class=\"headerlink\" title=\"6.2 主要特性\"></a>6.2 主要特性</h5><hr>\n<ul>\n<li>快速持久化：可以在O(1)的系统开销下进行消息持久化；</li>\n<li>高吞吐：在一台普通的服务器上既可以达到10W/s的吞吐速率；</li>\n<li>完全的分布式系统：Broker、Producer和Consumer都原生自动支持分布式，自动实现负载均衡；</li>\n<li>支持同步和异步复制两种高可用机制；</li>\n<li>支持数据批量发送和拉取；</li>\n<li>零拷贝技术(zero-copy)：减少IO操作步骤，提高系统吞吐量；</li>\n<li>数据迁移、扩容对用户透明；</li>\n<li>无需停机即可扩展机器；</li>\n<li>其他特性：丰富的消息拉取模型、高效订阅者水平扩展、实时的消息订阅、亿级的消息堆积能力、定期删除机制；</li>\n</ul>\n<h5 id=\"6-3-优缺点\"><a href=\"#6-3-优缺点\" class=\"headerlink\" title=\"6.3 优缺点\"></a>6.3 优缺点</h5><hr>\n<p><code>优点</code>：</p>\n<ul>\n<li>客户端语言丰富：支持Java、.Net、PHP、Ruby、Python、Go等多种语言；</li>\n<li>高性能：单机写入TPS约在100万条/秒，消息大小10个字节；</li>\n<li>提供完全分布式架构，并有replica机制，拥有较高的可用性和可靠性，理论上支持消息无限堆积；</li>\n<li>支持批量操作；</li>\n<li>消费者采用Pull方式获取消息。消息有序，通过控制能够保证所有消息被消费且仅被消费一次；</li>\n<li>有优秀的第三方KafkaWeb管理界面Kafka-Manager；</li>\n<li>在日志领域比较成熟，被多家公司和多个开源项目使用。</li>\n</ul>\n<p><code>缺点</code>：</p>\n<ul>\n<li>Kafka单机超过64个队列/分区时，Load时会发生明显的飙高现象。队列越多，负载越高，发送消息响应时间变长；</li>\n<li>使用短轮询方式，实时性取决于轮询间隔时间；</li>\n<li>消费失败不支持重试；</li>\n<li>支持消息顺序，但是一台代理宕机后，就会产生消息乱序；</li>\n<li>社区更新较慢。</li>\n</ul>\n<h4 id=\"7-常见消息中间件对比分析图\"><a href=\"#7-常见消息中间件对比分析图\" class=\"headerlink\" title=\"7. 常见消息中间件对比分析图\"></a>7. 常见消息中间件对比分析图</h4><hr>\n<p><img src=\"../img/MQ/2-2.png\" alt=\"对比分析图\"></p>\n<h4 id=\"8-适用场景分析\"><a href=\"#8-适用场景分析\" class=\"headerlink\" title=\"8.适用场景分析\"></a>8.适用场景分析</h4><hr>\n<p><code>从公司基础建设力量角度</code>：</p>\n<ul>\n<li><p>中小型软件公司，建议选RabbitMQ，一方面，erlang语言天生具备高并发的特性，而且他的管理界面用起来十分方便。他的弊端也在这里，虽然RabbitMQ是开源的，然而国内有几个能定制化开发erlang的程序员呢？所幸，RabbitMQ的社区十分活跃，可以解决开发过程中遇到的bug，这点对于中小型公司来说十分重要。不考虑RocketMQ和kafka的原因是，一方面中小型软件公司不如互联网公司，数据量没那么大，选消息中间件，应首选功能比较完备的，所以kafka排除。不考虑RocketMQ的原因是，RocketMQ是阿里出品，如果阿里放弃维护RocketMQ，中小型公司一般抽不出人来进行RocketMQ的定制化开发，因此不推荐。</p>\n</li>\n<li><p>大型软件公司，根据具体使用在RocketMQ和kafka之间二选一。一方面，大型软件公司，具备足够的资金搭建分布式环境，也具备足够大的数据量。针对RocketMQ,大型软件公司也可以抽出人手对RocketMQ进行定制化开发，毕竟国内有能力改JAVA源码的人，还是相当多的。至于kafka，根据业务场景选择，如果有日志采集功能，肯定是首选kafka了。</p>\n</li>\n</ul>\n<p><code>从业务场景角度出发</code>:</p>\n<ul>\n<li>RocketMQ定位于非日志的可靠消息传输（日志场景也OK），目前RocketMQ在阿里集团被广泛应用在订单，交易，充值，流计算，消息推送，日志流式处理，binglog分发等场景。</li>\n<li>Kafka是LinkedIn开源的分布式发布-订阅消息系统，目前归属于Apache定级项目。Kafka主要特点是基于Pull的模式来处理消息消费，追求高吞吐量，一开始的目的就是用于日志收集和传输。0.8版本开始支持复制，不支持事务，对消息的重复、丢失、错误没有严格要求，适合产生大量数据的互联网服务的数据收集业务。</li>\n<li>RabbitMQ是使用Erlang语言开发的开源消息队列系统，基于AMQP协议来实现。AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。AMQP协议更多用在企业系统内，对数据一致性、稳定性和可靠性要求很高的场景，对性能和吞吐量的要求还在其次。</li>\n</ul>\n","feature":true,"text":"在了解了消息队列的常用场景后，我们考虑接下来的选型问题。如今使用较多的消息队列有ActiveMQ、RabbitMQ、ZeroMQ、Kafka、MetaMQ、RocketMQ等，以及部分数据库如Redis也可以实现消息队列功能。我们该选择哪一种来引入我们的项目中呢？那么接下来，主要...","link":"","photos":[],"count_time":{"symbolsCount":"5.8k","symbolsTime":"5 mins."},"categories":[{"name":"MQ","slug":"MQ","count":3,"path":"api/categories/MQ.json"}],"tags":[{"name":"MQ选型","slug":"MQ选型","count":1,"path":"api/tags/MQ选型.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-RabbitMQ\"><span class=\"toc-text\">1. RabbitMQ</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-1-%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">1.1 概述</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-2-%E7%89%B9%E6%80%A7\"><span class=\"toc-text\">1.2 特性</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-3-%E4%BC%98%E7%BC%BA%E7%82%B9\"><span class=\"toc-text\">1.3 优缺点</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-Redis\"><span class=\"toc-text\">2.Redis</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-ZeroMQ\"><span class=\"toc-text\">3.ZeroMQ</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-1-%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">3.1 概述</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-2-%E7%89%B9%E6%80%A7\"><span class=\"toc-text\">3.2 特性</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-3-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">3.3 应用场景</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-ActiveMQ\"><span class=\"toc-text\">4.ActiveMQ</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-1%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">4.1概述</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-2-%E7%89%B9%E6%80%A7\"><span class=\"toc-text\">4.2 特性</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-3-%E4%BC%98%E7%BC%BA%E7%82%B9\"><span class=\"toc-text\">4.3 优缺点</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-RocketMQ\"><span class=\"toc-text\">5.RocketMQ</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#5-1-%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">5.1 概述</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#5-2-%E4%B8%BB%E8%A6%81%E7%89%B9%E6%80%A7\"><span class=\"toc-text\">5.2 主要特性</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#5-3-%E4%BC%98%E7%BC%BA%E7%82%B9\"><span class=\"toc-text\">5.3 优缺点</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-Kafka-jafka\"><span class=\"toc-text\">6.Kafka&#x2F;jafka</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#6-1-%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">6.1 概述</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#6-2-%E4%B8%BB%E8%A6%81%E7%89%B9%E6%80%A7\"><span class=\"toc-text\">6.2 主要特性</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#6-3-%E4%BC%98%E7%BC%BA%E7%82%B9\"><span class=\"toc-text\">6.3 优缺点</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#7-%E5%B8%B8%E8%A7%81%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90%E5%9B%BE\"><span class=\"toc-text\">7. 常见消息中间件对比分析图</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#8-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90\"><span class=\"toc-text\">8.适用场景分析</span></a></li></ol>","author":{"name":"安安哎呀呀","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/img_convert/71d174e6f2050f828d65a741734d6e0c.png","link":"/","description":"山内有樱名为良，树本无名只待春","socials":{"github":"https://github.com/JeryLiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/243662531"},"jianshu":{"icon":"/svg/jianshu.svg","link":"https://www.jianshu.com/u/f1275d68d75d"}}}},"mapped":true,"prev_post":{"title":"消息队列(三)——kafka","uid":"1a334e4ba9c2396d196ceadace888870","slug":"消息队列-三-——kafka","date":"2019-12-09T13:55:28.000Z","updated":"2021-08-16T12:57:26.890Z","comments":true,"path":"api/articles/消息队列-三-——kafka.json","keywords":null,"cover":"../img/MQ/cover3.png","text":"在通过消息队列（一）与消息队列（二），相信大家已经对消息队列的几大应用场景，以及各大消息队列中间件的优缺点，那么我们接下来将要讲述的是分布式发布订阅消息系统——kafka的一些相关概念与术语的介绍。 1、简介 1.1 概述 Kafka是最初由Linkedin公司开发，是一种高吞吐...","link":"","photos":[],"count_time":{"symbolsCount":"3.4k","symbolsTime":"3 mins."},"categories":[{"name":"MQ","slug":"MQ","count":3,"path":"api/categories/MQ.json"}],"tags":[{"name":"kafka","slug":"kafka","count":1,"path":"api/tags/kafka.json"}],"author":{"name":"安安哎呀呀","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/img_convert/71d174e6f2050f828d65a741734d6e0c.png","link":"/","description":"山内有樱名为良，树本无名只待春","socials":{"github":"https://github.com/JeryLiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/243662531"},"jianshu":{"icon":"/svg/jianshu.svg","link":"https://www.jianshu.com/u/f1275d68d75d"}}}},"feature":true},"next_post":{"title":"消息队列(一)——消息队列的应用场景","uid":"96ba06db63c23312ef17859b33c16987","slug":"消息队列-一-——消息队列的应用场景","date":"2019-12-06T08:32:24.000Z","updated":"2021-08-16T12:40:35.607Z","comments":true,"path":"api/articles/消息队列-一-——消息队列的应用场景.json","keywords":null,"cover":"../img/MQ/cover1.png","text":"1. 什么是消息队列 队列相信大家应该都不陌生，它是一种先进先出的数据结构，基本结构如下图。 在java中已经实现了各种各样的队列了，那为什么还需要消息队列MQ（Message Queue）这种中间件呢？我们可以先尝试思考一下消息队列存在的意义，它能满足我们项目中的什么需求，下面...","link":"","photos":[],"count_time":{"symbolsCount":"2.4k","symbolsTime":"2 mins."},"categories":[{"name":"MQ","slug":"MQ","count":3,"path":"api/categories/MQ.json"}],"tags":[{"name":"MQ应用场景","slug":"MQ应用场景","count":1,"path":"api/tags/MQ应用场景.json"}],"author":{"name":"安安哎呀呀","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/img_convert/71d174e6f2050f828d65a741734d6e0c.png","link":"/","description":"山内有樱名为良，树本无名只待春","socials":{"github":"https://github.com/JeryLiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/243662531"},"jianshu":{"icon":"/svg/jianshu.svg","link":"https://www.jianshu.com/u/f1275d68d75d"}}}},"feature":true}}