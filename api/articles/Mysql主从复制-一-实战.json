{"title":"Mysql主从复制(一)--实战","uid":"db73b6318bddc8aeb59536b254b9242c","slug":"Mysql主从复制-一-实战","date":"2019-06-03T06:55:03.000Z","updated":"2021-07-01T08:25:55.206Z","comments":true,"path":"api/articles/Mysql主从复制-一-实战.json","keywords":null,"cover":"../img/Mysql/cover.jpeg","content":"<p>在开始实际讲解MySQL主从复制如何实现之前，我们可以先思考一个问题！那就是，我们为什么要用数据库主从复制呢？它能为我们解决什么业务问题？在思考过后我们开始进入正题吧！</p>\n<h4 id=\"1-MySQL主从复制是什么？\"><a href=\"#1-MySQL主从复制是什么？\" class=\"headerlink\" title=\"1.MySQL主从复制是什么？\"></a>1.MySQL主从复制是什么？</h4><p>主从同步使得数据可以从一个数据库服务器复制到其他服务器上，在复制数据时，一个服务器充当主服务器（master），其余的服务器充当从服务器（slave）。因为复制是异步进行的，所以从服务器不需要一直连接着主服务器，从服务器甚至可以通过拨号断断续续地连接主服务器。通过配置文件，可以指定复制所有的数据库，某个数据库，甚至是某个数据库上的某个表。</p>\n<p>####2.单台MySQL服务器的局限性</p>\n<ul>\n<li>无热备数据库，当数据库服务器故障后，所有服务都将暂停，同时可能丢失未能及时存储的数据；</li>\n<li>同样，随着业务的扩展，业务量越来越大，I/O频率过高，这使得数据库的性能越来越差。</li>\n</ul>\n<p>####3.主从复制解决的问题</p>\n<h5 id=\"3-1数据备份\"><a href=\"#3-1数据备份\" class=\"headerlink\" title=\"3.1数据备份\"></a>3.1数据备份</h5><p>提高数据安全-因为数据已复制到从服务器，从服务器可以终止复制进程，所以，可以在从服务器上备份而不破坏主服务器相应数据；<br>#####3.2高可用</p>\n<ul>\n<li>因为数据库服务器中的数据都是相同的，当Master挂掉后，可以指定一台Slave充当Master继续保证服务的运行，因为数据是一致性的（如果当插入时Master就挂掉，可能不一致，因为同步也需要时间）当然这种配置不是简单的把一台Slave充当Master，毕竟还要考虑后续的Slave的数据同步到Master。 </li>\n<li>在主服务器上执行写入和更新，在从服务器上向外提供读功能，达到读写分离的效果，也可以动态地调整从服务器的数量，从而调整整个数据库的性能；读写分离详见<a href=\"https://www.jianshu.com/p/bc45c8bccf3c\">另一篇文章</a></li>\n<li>在主服务器上生成实时数据，而在从服务器上分析这些数据，从而提高主服务器的性能。</li>\n</ul>\n<h4 id=\"4-主从复制的原理\"><a href=\"#4-主从复制的原理\" class=\"headerlink\" title=\"4.主从复制的原理\"></a>4.主从复制的原理</h4><p><img src=\"../img/Mysql/1.png\" alt=\"主从复制原理图\"><br>Master服务器将数据的改变记录二进制日志，当Master上的数据发生改变时，则将其改变写入二进制日志中，Salve服务器会在一定时间间隔内对Master二进制日志进行探测其是否发生改变，如果发生改变，则开始一个I/OThread请求Master二进制事件，同时主节点为每个I/O线程启动一个线程，用于向其发送二进制事件，并保存至从节点本地的中继日志中，从节点将启动SQL线程从中继日志中读取二进制日志，在本地重放，使得其数据和主节点的保持一致，最后I/OThread和SQLThread将进入睡眠状态，等待下一次被唤醒。</p>\n<h4 id=\"5-配置实现主从复制\"><a href=\"#5-配置实现主从复制\" class=\"headerlink\" title=\"5.配置实现主从复制\"></a>5.配置实现主从复制</h4><p>环境如下：<br>| 名称|版本| MySQL版本| IP|<br>|——-|—|———–|——-|<br>| 主数据库| Centos7.3| 5.7| 192.168.xx.xx |<br>| 从数据库| Centos7.3| 5.7| 192.168.yy.yy|</p>\n<p>#####5.1主数据库配置</p>\n<ul>\n<li>修改MySQL配置<br>查看数据库配置文件<code> vi /etc/my.cnf</code>，在<code>[mysqld]</code>下插入如下两行：<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">[mysqld]\nlog-bin&#x3D;mysql-bin # 开启二进制日志\nserver-id&#x3D;1 #设置server-id，需要唯一</code></pre>\n可选参数如下(注意：使用时二选一)：<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">#不同步哪些数据库，除此之外别的都同步\nbinlog-ignore-db &#x3D; information_schema \nbinlog-ignore-db &#x3D; mysql\n\n#只同步哪些数据库，除此之外别的都不同步\nbinlog-do-db &#x3D; test</code></pre></li>\n<li>重启MySQL，创建用于同步的用户账号<br>进入mysql，创建用户(此用户的目的是让从数据库登录主服务器)并授权：用户名：<code>MySlave</code>，密码：<code>password</code>；<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">systemctl restart mysqld #重启mysql\nmysql -u root -p #进入数据库\n\n# 创建用户，其中用户名后的为从数据ip地址\nmysql&gt; CREATE USER &#39;MySlave&#39;@&#39;192.168.yy.yy&#39; IDENTIFIED BY &#39;password&#39;；\n#分配权限  \nmysql&gt; GRANT REPLICATION SLAVE ON *.* TO &#39;MySlave&#39;@&#39;192.168.yy.yy&#39;；\n#刷新权限\nmysql&gt;FLUSH PRIVILEGES；\n</code></pre></li>\n<li>查看Master状态，记录二进制文件名和位置<br>可以看到当前记录的二进制文件为<code>mysql-bin.000007</code>，位置为<code>1539</code><br><img src=\"../img/Mysql/2.png\" alt=\"master状态图\"><h5 id=\"5-2从数据库配置\"><a href=\"#5-2从数据库配置\" class=\"headerlink\" title=\"5.2从数据库配置\"></a>5.2从数据库配置</h5></li>\n<li>修改mysql配置<br>查看数据库配置文件<code> vi /etc/my.cnf</code>，在<code>[mysqld]</code>下插入如下两行：<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">[mysqld]\nlog-bin&#x3D;mysql-bin # 开启二进制日志\nserver-id&#x3D;2 #设置server-id，需要唯一</code></pre></li>\n<li>重启mysql，并进入mysql，进行手动同步<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">mysql&gt; CHANGE MASTER TO\n    MASTER_HOST&#x3D;&#39;192.168.xx.xx&#39;,\n    MASTER_USER&#x3D;&#39;MySlave&#39;,\n    MASTER_PASSWORD&#x3D;&#39;password&#39;,\n    MASTER_LOG_FILE&#x3D;&#39;mysql-bin.000007&#39;,\n    MASTER_LOG_POS&#x3D;1539;</code></pre></li>\n<li>启动salve同步进程<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">mysql &gt; start slave；</code></pre></li>\n<li>查看slave状态<br>当<code>Slave_IO_Running: Yes</code>，<code>Slave_SQL_Running: Yes</code>时说明两个线程启动成功，主从复制配置完成了！<pre class=\"line-numbers language-none\"><code class=\"language-none\">mysql &gt; show slave status\\G；</code></pre>\n<img src=\"../img/Mysql/3.png\" alt=\"slave状态图\"></li>\n</ul>\n<h4 id=\"6-测试\"><a href=\"#6-测试\" class=\"headerlink\" title=\"6.测试\"></a>6.测试</h4><p>主数据库新建jerry表：<br><img src=\"../img/Mysql/4.png\" alt=\"image.png\"><br>然后在从数据库中刷新，可以看到新建的表：<br><img src=\"../img/Mysql/5.png\" alt=\"image.png\"></p>\n<p>注意：<br>若我们在进行数据库主从复制前，为以下情况的一种：</p>\n<ul>\n<li>第一种情况：Master中无任何数据，Slave中也同样无任何数据</li>\n<li>第二种情况：Master中已有表和数据，Slave是无表和无数据的</li>\n</ul>\n<p>若为第一种情况，直接配置即可。</p>\n<p>若为第二种情况，会有一个问题(踩过这坑=-=)，那就是如果我们之前有数据，<strong>而我们同步时输入的是最新的偏移位置，是会忽略以前的数据操作的</strong>，为此如果这个时候我们在Master以前的表中插入新数据，你会发现并不会在Slave中看到该数据，而会产生错误，这时候如果没有在Master的mysql配置文件my.cnf中配置忽略错误<code>slave-skip-errors=1</code>时，<code>Slave_SQL_Running</code>线程会关闭，我们再查看状态会发现其为<code>Slave_SQL_Running: NO</code>。<br>这种情况的解决办法是：手动导出sql文件并在Slave中运行，使得两者为一致状态；然后我们再重新手动同步。</p>\n","text":"在开始实际讲解MySQL主从复制如何实现之前，我们可以先思考一个问题！那就是，我们为什么要用数据库主从复制呢？它能为我们解决什么业务问题？在思考过后我们开始进入正题吧！ 1.MySQL主从复制是什么？主从同步使得数据可以从一个数据库服务器复制到其他服务器上，在复制数据时，一个服务...","link":"","photos":[],"count_time":{"symbolsCount":"2.9k","symbolsTime":"3 mins."},"categories":[{"name":"Database","slug":"Database","count":3,"path":"api/categories/Database.json"}],"tags":[{"name":"Mysql","slug":"Mysql","count":3,"path":"api/tags/Mysql.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">1.MySQL主从复制是什么？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-1%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD\"><span class=\"toc-text\">3.1数据备份</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">4.主从复制的原理</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6\"><span class=\"toc-text\">5.配置实现主从复制</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#5-2%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">5.2从数据库配置</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-%E6%B5%8B%E8%AF%95\"><span class=\"toc-text\">6.测试</span></a></li></ol>","author":{"name":"安安哎呀呀","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"山内有樱名为良，树本无名只待春","socials":{"github":"https://github.com/JeryLiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/243662531"},"jianshu":{"icon":"/svg/jianshu.svg","link":"https://www.jianshu.com/u/f1275d68d75d"}}}},"mapped":true,"prev_post":{"title":"Mysql读写分离","uid":"c2a3674366d1787c09a254e4e4c87ed4","slug":"Mysql读写分离","date":"2019-06-04T06:58:09.000Z","updated":"2021-07-01T08:32:17.748Z","comments":true,"path":"api/articles/Mysql读写分离.json","keywords":null,"cover":"../img/Mysql读写分离/cover.jpeg","text":"实现MySQL读写分离的前提是我们已经将MySQL主从复制配置完毕，可参考我上一篇关于MySQL主从复制的文章。读写分离实现方式：1）配置多数据源；2）使用mysql的proxy中间件代理工具；第一种方式中，数据库和Application是有一定侵入性的，即我们的数据库更换时，a...","link":"","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[{"name":"Database","slug":"Database","count":3,"path":"api/categories/Database.json"}],"tags":[{"name":"Mysql","slug":"Mysql","count":3,"path":"api/tags/Mysql.json"}],"author":{"name":"安安哎呀呀","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"山内有樱名为良，树本无名只待春","socials":{"github":"https://github.com/JeryLiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/243662531"},"jianshu":{"icon":"/svg/jianshu.svg","link":"https://www.jianshu.com/u/f1275d68d75d"}}}}},"next_post":{"title":"微服务","uid":"4323338174440016aba5335d086cc950","slug":"微服务","date":"2019-05-28T06:54:26.000Z","updated":"2021-07-28T12:04:09.828Z","comments":true,"path":"api/articles/微服务.json","keywords":null,"cover":"../img/微服务/cover.jpeg","text":"1 单体应用架构一个归档包(例如war包格式)包含所有功能的应用程序，通常称为单体应用，而架构单体应用的方法，就是单体应用架构。以下为电影售票系统单体架构示意图。 单体应用存在的一些问题： 复杂性高：项目中可能存在包含模块非常多，但是模块的边界模糊、依赖关系不清晰、代码质量参差不...","link":"","photos":[],"count_time":{"symbolsCount":"2.9k","symbolsTime":"3 mins."},"categories":[{"name":"Java","slug":"Java","count":8,"path":"api/categories/Java.json"}],"tags":[{"name":"Microservice","slug":"Microservice","count":2,"path":"api/tags/Microservice.json"}],"author":{"name":"安安哎呀呀","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"山内有樱名为良，树本无名只待春","socials":{"github":"https://github.com/JeryLiang","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/243662531"},"jianshu":{"icon":"/svg/jianshu.svg","link":"https://www.jianshu.com/u/f1275d68d75d"}}}}}}